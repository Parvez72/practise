'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var express = require('express');
var bodyParser = require('body-parser');
var vault = require('./models/vault');
var q = require('q');
var _a = require('./models/utils/bot'), isBotPaused = _a.isBotPaused, unPauseBot = _a.unPauseBot;
var url = require('url');
var _b = require('./models/memory'), Memory = _b.Memory, refreshContext = _b.refreshContext;
var getStep = require('./models/action-lib').getStep;
var metrics = require('metrics-druid');
var sendTyping = require('./models/sendData').sendTyping;
var path = require('path');
var uid = require('uuid/v1')();
var bot = 'test';
var app = express();
var library_1 = require("./models/library");
exports.App = library_1.App;
var allFunctions = library_1.functions || {};
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');
app.use(bodyParser.json({ limit: '5mb' }));
app.use(function (req, res, next) {
    res.publish = function (success, message, data) {
        res.send({
            success: success,
            message: message || '',
            data: data || {}
        });
    };
    next();
});
app.get('/', function (req, res) {
    res.render('index', { bot: bot, uid: uid });
});
app.get('/functions', function (req, res) {
    res.publish(true, 'Success', Object.keys(allFunctions).map((function (currentValue) {
        return {
            name: currentValue
        };
    })).filter(function (current) {
        return current.name !== 'main';
    }));
});
app.get('/refresh-context', function (req, res) {
    refreshContext(bot, uid);
    res.publish(true, 'success', {});
});
app.post('/receive', function (req, res) {
    var requestBody = req.body;
    var extraParams = requestBody.extraParams;
    var sessionObject = requestBody.sessionObject;
    vault.getProfile(requestBody.sender, extraParams && extraParams.referrer && extraParams.orchestratorBotId ? extraParams.referrer : requestBody.bot, requestBody.source, requestBody.mapping).then(function (profile) {
        vault.getCode(requestBody.bot).then(function (response) {
            var ymApp = new library_1.App({
                botIdentifier: requestBody.botIdentifier,
                sender: requestBody.sender,
                bot: requestBody.bot,
                mapping: requestBody.mapping,
                profile: profile ? profile.data : undefined,
                source: requestBody.source,
                data: requestBody.data,
                messageId: requestBody.messageId,
                sessionObject: sessionObject,
                receivedMessageTime: requestBody.receivedMessageTime,
                allFunctions: allFunctions,
                referrer: extraParams && extraParams.referrer ? extraParams.referrer : undefined,
                orchestratorBotId: extraParams && extraParams.orchestratorBotId ? extraParams.orchestratorBotId : undefined,
                publish: res.publish
            });
            var executeMain = function () {
                //pushing profile events for firstTime user
                if (profile && profile.firstTime && (requestBody.mapping.userName.startsWith('x') || requestBody.source !== 'yellowmessenger')) {
                    metrics.increment('events.new-user.count', {
                        user: requestBody.mapping.userName,
                        platform: requestBody.source,
                        uid: requestBody.sender
                    });
                    vault.updateFirstTimeUser(requestBody.sender, extraParams && extraParams.referrer && extraParams.orchestrator ? extraParams.referrer : requestBody.bot, requestBody.source);
                }
                var timeDelta = sessionObject.time ? (new Date().getTime() - new Date(sessionObject.time).getTime()) / 1000 : 0;
                metrics.increment("events.messages.count", __assign({ uid: requestBody.sender, source: requestBody.source, user: requestBody.bot, sessionId: sessionObject && sessionObject.sessionId ? sessionObject.sessionId : undefined, message: requestBody.data.message, messageType: 'USER' }, profile), timeDelta);
                if (requestBody.source === 'yellowmessenger' || requestBody.source === 'facebook') {
                    isBotPaused(requestBody.bot, requestBody.sender, requestBody.source).then(function (res) {
                        var unPauseMessages = ['bot', 'talk to bot'];
                        if (requestBody.data && requestBody.data.message && (unPauseMessages.indexOf(requestBody.data.message.toLowerCase().trim()) !== -1 || (requestBody.mapping && requestBody.mapping.unPauseTerms && requestBody.mapping.unPauseTerms.split(',').indexOf(requestBody.data.message.toLowerCase().trim()) !== -1))) {
                            unPauseBot(requestBody.bot, requestBody.sender, requestBody.source);
                            sendTyping(requestBody.bot, requestBody.sender).then(function (res) {
                                try {
                                    var result = allFunctions['main'](ymApp);
                                    if (result instanceof Promise) {
                                        result.then(function () {
                                            ymApp = null;
                                        });
                                    }
                                }
                                catch (e) {
                                    if (ymApp) {
                                        ymApp.logger.log(e.stack, "error");
                                    }
                                }
                            });
                        }
                        else if (requestBody.data.event) {
                            try {
                                var result = allFunctions['main'](ymApp);
                                if (result instanceof Promise) {
                                    result.then(function () {
                                        ymApp = null;
                                    });
                                }
                            }
                            catch (e) {
                                if (ymApp) {
                                    ymApp.logger.log(e.stack, "error");
                                }
                            }
                        }
                    }, function (err) {
                        if (requestBody.data.event) {
                            try {
                                var result = allFunctions['main'](ymApp);
                                if (result instanceof Promise) {
                                    result.then(function () {
                                        ymApp = null;
                                    });
                                }
                            }
                            catch (e) {
                                if (ymApp) {
                                    ymApp.logger.log(e.stack, "error");
                                }
                            }
                        }
                        else {
                            sendTyping(requestBody.bot, requestBody.sender).then(function (res) {
                                try {
                                    var result = allFunctions['main'](ymApp);
                                    if (result instanceof Promise) {
                                        result.then(function () {
                                            ymApp = null;
                                        });
                                    }
                                }
                                catch (e) {
                                    if (ymApp) {
                                        ymApp.logger.log(e.stack, "error");
                                    }
                                }
                            });
                        }
                    });
                }
                else {
                    try {
                        var result = allFunctions['main'](ymApp);
                        if (result instanceof Promise) {
                            result.then(function () {
                                ymApp = null;
                            });
                        }
                    }
                    catch (e) {
                        if (ymApp) {
                            ymApp.logger.log(e.stack, "error");
                        }
                    }
                }
            };
            executeMain();
            if (requestBody.source === 'yellowmessenger' || requestBody.source === 'facebook') {
                res.sendStatus(200);
            }
        });
    });
});
app.post('/executeFunction', function (req, res) {
    var requestBody = req.body;
    var extraParams = requestBody.extraParams;
    vault.getProfile(requestBody.sender, requestBody.referrer || requestBody.bot, 'yellowmessenger').then(function (profile) {
        var ymApp = new library_1.App({
            botIdentifier: requestBody.bot,
            sender: requestBody.sender,
            bot: requestBody.bot,
            mapping: requestBody.mapping,
            profile: profile ? profile.data : undefined,
            source: 'yellowmessenger',
            allFunctions: allFunctions,
            publish: res.publish,
            runDefaultFunction: true,
            data: {},
            referrer: requestBody.referrer,
            triggerJourney: requestBody.triggerJourney
        });
        try {
            var result = ymApp.executeFunction(requestBody.funcName, undefined, true);
            if (result instanceof Promise) {
                result.then(function () {
                    ymApp = null;
                });
            }
        }
        catch (e) {
            if (ymApp) {
                ymApp.logger.log(e.stack, "error");
            }
        }
    });
});
app.get('/getAutoComplete', function (req, res) {
    var queryObject = url.parse(req.url, true).query;
    if (req.query.bot && req.query.sender && req.query.term) {
        if (req.query.functionName) {
            var app_1 = new library_1.App({
                bot: req.query.bot,
                sender: req.query.sender,
                term: req.query.term
            });
            try {
                allFunctions[req.query.functionName](app_1).then(function (data) {
                    res.publish(true, 'success', {
                        'autoComplete': data
                    });
                });
            }
            catch (e) {
                res.publish(true, 'failure', {
                    'autoComplete': [],
                    'error': e
                });
            }
        }
        else {
            var memory = new Memory(req.query.bot, req.query.sender);
            memory.get("context").then(function (context) {
                context = JSON.parse(context);
                if (context.journeyId && context.paramExpected) {
                    getStep(context.journeyId, context.paramExpected).then(function (stepDetails) {
                        if (stepDetails && stepDetails.autoComplete) {
                            var app_2 = new library_1.App({
                                bot: req.query.bot,
                                sender: req.query.sender,
                                term: req.query.term
                            });
                            try {
                                allFunctions[stepDetails.autoComplete](app_2).then(function (data) {
                                    res.publish(true, 'success', {
                                        'autoComplete': data
                                    });
                                });
                            }
                            catch (e) {
                                res.publish(true, 'failure', {
                                    'autoComplete': [],
                                    'error': e
                                });
                            }
                        }
                        else {
                            res.publish(true, 'failure', {
                                autoComplete: [],
                                error: {}
                            });
                        }
                    });
                }
                else {
                    res.publish(true, 'failure', {
                        autoComplete: [],
                        error: {}
                    });
                }
            }, function () {
                res.publish(true, 'failure', {
                    autoComplete: [],
                    error: {}
                });
            });
        }
    }
    else {
        res.publish(true, 'failure', {
            autoComplete: [],
            error: {}
        });
    }
});
var serve = function (funcs, options) {
    library_1.updateFunctions(funcs);
    if (options.uid) {
        uid = options.uid;
    }
    if (options.bot) {
        bot = options.bot;
    }
    // Todo rest of the thing like ngrock thing
    app.listen(8888, function () { return console.log("Listening on port 8888"); });
};
exports.serve = serve;
