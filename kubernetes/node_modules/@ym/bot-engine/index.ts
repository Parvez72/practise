'use strict';
const express = require('express');
const bodyParser = require('body-parser');

const vault = require('./models/vault');
const q = require('q');
const {isBotPaused, unPauseBot} = require('./models/utils/bot');
const url = require('url');
const {Memory, refreshContext} = require('./models/memory');
const {getStep} = require('./models/action-lib');
const metrics = require('metrics-druid');
const {sendTyping} = require('./models/sendData');
const path = require('path');

let uid = require('uuid/v1')();
let bot = 'test';

const app = express();
import {App, updateFunctions, functions} from './models/library';

const allFunctions = functions || {} as any;

app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

app.use(bodyParser.json({limit: '5mb'}));

app.use(function (req, res, next) {
    res.publish = (success, message, data) => {
        res.send({
            success: success,
            message: message || '',
            data: data || {}
        });
    };
    next();
});

app.get('/', (req, res) => {
    res.render('index', {bot, uid});
});

app.get('/functions', (req, res) => {
    res.publish(true, 'Success', Object.keys(allFunctions).map(((currentValue) => {
        return {
            name: currentValue
        }
    })).filter((current) => {
        return current.name !== 'main';
    }));
});

app.get('/refresh-context', (req, res) => {
    refreshContext(bot, uid);
    res.publish(true, 'success', {});
});

app.post('/receive', (req, res) => {
    let requestBody = req.body;
    let extraParams = requestBody.extraParams;
    let sessionObject = requestBody.sessionObject;
    vault.getProfile(requestBody.sender, extraParams && extraParams.referrer && extraParams.orchestratorBotId ? extraParams.referrer : requestBody.bot, requestBody.source, requestBody.mapping).then((profile) => {
        vault.getCode(requestBody.bot).then((response) => {
            let ymApp = new App({
                botIdentifier: requestBody.botIdentifier,
                sender: requestBody.sender,
                bot: requestBody.bot,
                mapping: requestBody.mapping,
                profile: profile ? profile.data : undefined,
                source: requestBody.source,
                data: requestBody.data,
                messageId: requestBody.messageId,
                sessionObject: sessionObject,
                receivedMessageTime: requestBody.receivedMessageTime,
                allFunctions: allFunctions,
                referrer: extraParams && extraParams.referrer ? extraParams.referrer : undefined,
                orchestratorBotId: extraParams && extraParams.orchestratorBotId ? extraParams.orchestratorBotId : undefined,
                publish: res.publish
            });

            let executeMain = function () {
                //pushing profile events for firstTime user
                if (profile && profile.firstTime && (requestBody.mapping.userName.startsWith('x') || requestBody.source !== 'yellowmessenger')) {
                    metrics.increment('events.new-user.count', {
                        user: requestBody.mapping.userName,
                        platform: requestBody.source,
                        uid: requestBody.sender
                    });
                    vault.updateFirstTimeUser(requestBody.sender, extraParams && extraParams.referrer && extraParams.orchestrator ? extraParams.referrer : requestBody.bot, requestBody.source);
                }
                const timeDelta = sessionObject.time ? (new Date().getTime() - new Date(sessionObject.time).getTime()) / 1000 : 0;
                metrics.increment("events.messages.count", {
                    uid: requestBody.sender,
                    source: requestBody.source,
                    user: requestBody.bot,
                    sessionId: sessionObject && sessionObject.sessionId ? sessionObject.sessionId : undefined,
                    message: requestBody.data.message,
                    messageType: 'USER',
                    ...profile
                }, timeDelta);
                if (requestBody.source === 'yellowmessenger' || requestBody.source === 'facebook') {
                    isBotPaused(requestBody.bot, requestBody.sender, requestBody.source).then((res) => {
                        let unPauseMessages = ['bot', 'talk to bot'];
                        if (requestBody.data && requestBody.data.message && (unPauseMessages.indexOf(requestBody.data.message.toLowerCase().trim()) !== -1 || (requestBody.mapping && requestBody.mapping.unPauseTerms && requestBody.mapping.unPauseTerms.split(',').indexOf(requestBody.data.message.toLowerCase().trim()) !== -1))) {
                            unPauseBot(requestBody.bot, requestBody.sender, requestBody.source);
                            sendTyping(requestBody.bot, requestBody.sender).then((res) => {
                                try {
                                    let result = allFunctions['main'](ymApp);
                                    if (result instanceof Promise) {
                                        result.then(() => {
                                            ymApp = null;
                                        })
                                    }
                                } catch (e) {
                                    if (ymApp) {
                                        ymApp.logger.log(e.stack, "error");
                                    }
                                }
                            });


                        } else if (requestBody.data.event) {
                            try {
                                let result = allFunctions['main'](ymApp);
                                if (result instanceof Promise) {
                                    result.then(() => {
                                        ymApp = null;
                                    })
                                }
                            } catch (e) {
                                if (ymApp) {
                                    ymApp.logger.log(e.stack, "error");
                                }
                            }
                        }
                    }, (err) => {
                        if (requestBody.data.event) {
                            try {
                                let result = allFunctions['main'](ymApp);
                                if (result instanceof Promise) {
                                    result.then(() => {
                                        ymApp = null;
                                    })
                                }
                            } catch (e) {
                                if (ymApp) {
                                    ymApp.logger.log(e.stack, "error");
                                }
                            }
                        }
                        else {
                            sendTyping(requestBody.bot, requestBody.sender).then((res) => {
                                try {
                                    let result = allFunctions['main'](ymApp);
                                    if (result instanceof Promise) {
                                        result.then(() => {
                                            ymApp = null;
                                        })
                                    }
                                } catch (e) {
                                    if (ymApp) {
                                        ymApp.logger.log(e.stack, "error");
                                    }
                                }
                            });
                        }

                    });

                }
                else {
                    try {
                        let result = allFunctions['main'](ymApp);
                        if (result instanceof Promise) {
                            result.then(() => {
                                ymApp = null;
                            })
                        }
                    } catch (e) {
                        if (ymApp) {
                            ymApp.logger.log(e.stack, "error");
                        }
                    }
                }
            };

            executeMain();

            if (requestBody.source === 'yellowmessenger' || requestBody.source === 'facebook') {
                res.sendStatus(200);
            }

        })
    })
});

app.post('/executeFunction', function (req, res) {
    let requestBody = req.body;
    let extraParams = requestBody.extraParams;
    vault.getProfile(requestBody.sender, requestBody.referrer || requestBody.bot, 'yellowmessenger').then((profile) => {
        let ymApp = new App({
            botIdentifier: requestBody.bot,
            sender: requestBody.sender,
            bot: requestBody.bot,
            mapping: requestBody.mapping,
            profile: profile ? profile.data : undefined,
            source: 'yellowmessenger',
            allFunctions: allFunctions,
            publish: res.publish,
            runDefaultFunction: true,
            data: {},
            referrer: requestBody.referrer,
            triggerJourney: requestBody.triggerJourney
        });

        try {
            let result = ymApp.executeFunction(requestBody.funcName, undefined, true);
            if (result instanceof Promise) {
                result.then(()=>{
                    ymApp=null;
                })
            }
        } catch (e) {
            if (ymApp) {
                ymApp.logger.log(e.stack, "error");
            }
        }
    });
});

app.get('/getAutoComplete', (req, res) => {
    let queryObject = url.parse(req.url, true).query;
    if (req.query.bot && req.query.sender && req.query.term) {
        if (req.query.functionName) {
            let app = new App({
                bot: req.query.bot,
                sender: req.query.sender,
                term: req.query.term
            });
            try {
                allFunctions[req.query.functionName](app).then((data) => {
                    res.publish(true, 'success', {
                        'autoComplete': data
                    });
                });
            } catch (e) {
                res.publish(true, 'failure', {
                    'autoComplete': [],
                    'error': e
                });
            }
        } else {
            const memory = new Memory(req.query.bot, req.query.sender);
            memory.get("context").then((context) => {
                context = JSON.parse(context);
                if (context.journeyId && context.paramExpected) {
                    getStep(context.journeyId, context.paramExpected).then((stepDetails) => {
                        if (stepDetails && stepDetails.autoComplete) {
                            let app = new App({
                                bot: req.query.bot,
                                sender: req.query.sender,
                                term: req.query.term
                            });
                            try {
                                allFunctions[stepDetails.autoComplete](app).then((data) => {
                                    res.publish(true, 'success', {
                                        'autoComplete': data
                                    });
                                });
                            } catch (e) {
                                res.publish(true, 'failure', {
                                    'autoComplete': [],
                                    'error': e
                                });
                            }
                        }
                        else {
                            res.publish(true, 'failure', {
                                autoComplete: [],
                                error: {}
                            })
                        }
                    })
                }
                else {
                    res.publish(true, 'failure', {
                        autoComplete: [],
                        error: {}
                    })
                }
            }, () => {
                res.publish(true, 'failure', {
                    autoComplete: [],
                    error: {}
                })
            })
        }
    }
    else {
        res.publish(true, 'failure', {
            autoComplete: [],
            error: {}
        })
    }
});

const serve = (funcs, options) => {
    updateFunctions(funcs);
    if (options.uid) {
        uid = options.uid;
    }
    if (options.bot) {
        bot = options.bot;
    }
    // Todo rest of the thing like ngrock thing
    app.listen(8888, () => console.log("Listening on port 8888"));
};

export {
    serve,
    App
};
