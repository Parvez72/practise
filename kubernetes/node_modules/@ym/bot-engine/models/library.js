'use strict';
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var bpConfig = require('../config'), config = require('../config'), uuidV1 = require('uuid/v1'), request = require('request').defaults({ pool: { maxSockets: 10 } }), metrics = require('metrics-druid'), mailer = require('./emailer'), _ = require('lodash'), crypto = require('crypto'), https = require("https"), mustache = require('mustache'), DataStore = require('./datastore').DataStore, _a = require('./memory'), Memory = _a.Memory, getContextOfOtherUser = _a.getContextOfOtherUser, actionLib = require('./action-lib'), emailSender = require('./emailSender'), rabbit = require('./rabbit'), agents = require('./agents'), AI = require('./ai').AI, vault = require('./vault'), facebook = require('./messages').facebook, ym = require('./messages').ym, botframework = require('./messages').botframework, sms = require('./messages').sms, line = require('./messages').line, Q = require('q'), cheerio = require('cheerio'), imageRequest = require('request').defaults({ encoding: null }), wordToNumber = require('./words-to-numbers'), googleAssistant = require('./messages').googleAssistant, alexa = require('./messages').alexa, kookoo = require('./messages').kookoo, twilio = require('./messages').twilio, numeral = require('numeral'), geolib = require('geolib'), time = require('time'), xml2json = require('xml2json'), sanitizeHtml = require('sanitize-html'), phoneParse = require('phone-parse'), phonetics = require('./utils/phonetics'), geoUtil = require('./utils/geoUtils'), machineComprehension = require('./utils/ml').machineComprehension, _b = require('./sendData'), sendResponse = _b.sendResponse, sendTyping = _b.sendTyping, createSasUrl = require('./upload').createSasUrl, axios = require('axios'), soap = require('soap'), _c = require('./utils/encryption'), encrypt = _c.encrypt, decrypt = _c.decrypt, requestretry = require('requestretry'), agentsInstance = axios.create({
    baseURL: config.urls.AGENTS_SERVICE,
    timeout: 1000
});
var botHelper = require('./utils/bot');
request.request = request;
//Overriding Promise
global.Promise = require("bluebird");
var translateClient = require('./utils/translateClient');
var Analytics = require('./analytics/analytics').Analytics;
var Orchestrator = require('./orchestrator/orchestrator').Orchestrator;
var Logger = require('./logger/logger').Logger;
var knowledge = require('./knowledge');
var ContextProcessor = function (app, botMapping) {
    var self = this;
    var context;
    var loadContext = function () {
        return new Promise(function (resolve, reject) {
            app.memory.get("context").then(function (contextString) {
                context = JSON.parse(contextString);
                resolve();
            }, function () {
                context = {};
                resolve();
            });
        });
    };
    var nextStep = function (journeyDetails) {
        var skipList = [];
        var result;
        try {
            if (!context.steps) {
                context.steps = {};
            }
            var dataProps = { source: app.source, options: app.options, profile: app.profile, steps: context.steps };
            for (var i_1 in journeyDetails.stepConditions) {
                if (journeyDetails.stepConditions[i_1].type === "channels") {
                    if (journeyDetails.stepConditions[i_1].channels.indexOf(app.source) !== -1) {
                        skipList.push(journeyDetails.stepConditions[i_1].step);
                    }
                }
                else if (journeyDetails.stepConditions[i_1].type === "steps") {
                    result = isNaN(context.steps[journeyDetails.stepConditions[i_1].rule.step]) && isNaN(journeyDetails.stepConditions[i_1].rule.value) ? eval("context.steps[journeyDetails.stepConditions[i].rule.step]" + journeyDetails.stepConditions[i_1].rule.operator + "journeyDetails.stepConditions[i].rule.value") : eval(Number(context.steps[journeyDetails.stepConditions[i_1].rule.step]) + journeyDetails.stepConditions[i_1].rule.operator + Number(journeyDetails.stepConditions[i_1].rule.value));
                    if (result) {
                        skipList.push(journeyDetails.stepConditions[i_1].step);
                    }
                }
            }
        }
        catch (e) {
            app.log(e);
        }
        var i = 0;
        for (; i < journeyDetails.steps.length; i++) {
            if (context.steps[journeyDetails.steps[i].slug] === undefined && skipList.indexOf(journeyDetails.steps[i].slug) === -1) {
                break;
            }
        }
        context.complete = false;
        if (i >= journeyDetails.steps.length) {
            context.complete = true;
            delete context.paramExpected;
            delete context.question;
            delete context.options;
            delete context.questionOptions;
            delete context.questionFunction;
            delete context.stepId;
        }
        else {
            context.paramExpected = journeyDetails.steps[i].slug;
            context.questionOptions = {};
            // if (action.params[i].hideInput) {
            //     if (!context.questionOptions) {
            //         context.questionOptions = {};
            //     }
            //     context.questionOptions.hideInput = true;
            // } else {
            //     delete context.questionOptions;
            // }
            // TODO This looks tobe wrong
            if (journeyDetails.steps[i].slug.options) {
            }
            else {
                delete context.options;
            }
        }
    };
    //a function to get randomize messages
    var randomizeMessages = function (array) {
        var randomNumber = Math.floor(Math.random() * array.length);
        if (randomNumber === array.length) {
            return array[randomNumber - 1];
        }
        else {
            return array[randomNumber];
        }
    };
    // a function to select the message type
    var selectMessageType = function (response, dataProps) {
        var msgSent;
        var showResponse = true;
        var result;
        // looping through all the filters
        for (var i in response.filters) {
            if (response.filters[i].type === "channels" && response.filters[i].channels && response.filters[i].channels.length > 0) {
                if (response.filters[i].channels.indexOf(app.source) === -1) {
                    showResponse = false;
                    break;
                }
            }
            else if (response.filters[i].type === "steps" && context.steps[response.filters[i].step]) {
                result = isNaN(context.steps[response.filters[i].step]) && isNaN(response.filters[i].value) ? eval("context.steps[response.filters[i].step]" + response.filters[i].operator + "response.filters[i].value") : eval(Number(context.steps[response.filters[i].step]) + response.filters[i].operator + Number(response.filters[i].value));
                if (!result) {
                    showResponse = false;
                    break;
                }
            }
            else if (response.filters[i].type === "custom") {
                result = isNaN(app.mustache.render(response.filters[i].expression, dataProps)) && isNaN(app.mustache.render(response.filters[i].value, dataProps)) ? eval("app.mustache.render(response.filters[i].expression,dataProps).toString()" + response.filters[i].operator + "mustache.render(response.filters[i].value,dataProps).toString()") : eval(Number(app.mustache.render(response.filters[i].expression, dataProps)) + response.filters[i].operator + Number(app.mustache.render(response.filters[i].value, dataProps)));
                if (!result) {
                    showResponse = false;
                    break;
                }
            }
        }
        if (showResponse) {
            switch (response.type) {
                case "Email":
                    var to_1 = response.to.split(',');
                    var subject_1 = response.subject;
                    var body_1 = response.body;
                    var html_1 = response.html;
                    msgSent = new Promise(function (resolve, reject) {
                        mailer.sendEmail(to_1, subject_1, body_1, {}, '', html_1);
                        resolve();
                    });
                    break;
                case "SMS":
                    break;
                case "Video":
                    msgSent = app.sendVideo({ url: response.url });
                    break;
                case "Clear":
                    msgSent = new Promise(function (resolve, reject) {
                        self.clearContext();
                        resolve();
                    });
                    break;
                case "quickReplies":
                    // Fill the template
                    response.quickReplies.title = app.mustache.render(randomizeMessages(response.quickReplies.title), dataProps);
                    msgSent = app.sendQuickReplies(response.quickReplies);
                    break;
                case "image":
                    msgSent = app.sendImage(response.image);
                    break;
                case "cards":
                    msgSent = app.sendCards(response.cards);
                    break;
                case "WelcomeMessage":
                    msgSent = app.sendWelcomeMessage(response.welcomeMessageText ? app.mustache.render(response.welcomeMessageText, dataProps) : undefined);
                    break;
                case "text":
                    msgSent = app.sendTextMessage(app.mustache.render(randomizeMessages(response.messages), dataProps));
                    break;
                case "TriggerIntent":
                    app.clearContext();
                    app.data.message = app.mustache.render(response.trigger, dataProps);
                    app.start();
                    return;
                case "Event":
                    var event_1 = response.event;
                    if (event_1.data) {
                        for (var key in event_1.data) {
                            if (event_1.data.hasOwnProperty(key)) {
                                event_1.data[key] = app.mustache.render(event_1.data[key], dataProps);
                            }
                        }
                    }
                    msgSent = app.sendEvent(event_1);
                    break;
                case "SupportTicket":
                    var ticket = response.ticket;
                    msgSent = app.createTicket(app.mustache.render(ticket.issue, dataProps), app.profile, ticket.route);
                    break;
                case "func":
                    msgSent = new Promise(function (resolve) {
                        var result = app.functionWrapper(response.func, response.args);
                        if (result instanceof Promise) {
                            result.then(function () {
                                resolve();
                            });
                        }
                        else {
                            resolve();
                        }
                    });
                    break;
                case "Database":
                    msgSent = new Promise(function (resolve, reject) {
                        var query = {};
                        for (var key in response.database.query) {
                            if (response.database.query.hasOwnProperty(key)) {
                                query[key] = app.mustache.render(response.database.query[key], dataProps);
                            }
                        }
                        app.datastore.find({
                            table: response.database.collection,
                            query: query
                        }).then(function (results) {
                            if (!results || results.length === 0) {
                                app.sendTextMessage(app.mustache.render(response.database.emptyMessage || "No results found", dataProps))
                                    .then(function () {
                                    resolve();
                                });
                            }
                            else {
                                var foundMessageSent = Promise.resolve();
                                if (response.database.foundMessage) {
                                    foundMessageSent = app.sendTextMessage(app.mustache.render(response.database.foundMessage, results[0]));
                                }
                                foundMessageSent.then(function () {
                                    var msgSent = undefined;
                                    switch (response.database.type) {
                                        case "Message":
                                            msgSent = app.sendTextMessage(app.mustache.render(response.database.message, results[0]));
                                            break;
                                        case "QuickReplies":
                                            msgSent = app.sendQuickReplies({
                                                title: app.mustache.render(response.database.quickReplies.title, results[0]),
                                                options: _.map(response.database.quickReplies, function (option) {
                                                    for (var key in option) {
                                                        if (option.hasOwnProperty(key)) {
                                                            option[key] = app.mustache.render(option[key], results[0]);
                                                        }
                                                    }
                                                })
                                            });
                                            break;
                                        case "Cards":
                                            msgSent = app.sendCards(_.map(results, function (result) {
                                                return {
                                                    image: result[response.database.card.image],
                                                    title: result[response.database.card.title],
                                                    text: result[response.database.card.text],
                                                    actions: _.map(response.database.card.actions, function (action) {
                                                        for (var key in action) {
                                                            if (action.hasOwnProperty(key)) {
                                                                action[key] = app.mustache.render(action[key], results[0]);
                                                            }
                                                        }
                                                        return action;
                                                    })
                                                };
                                            }));
                                            break;
                                        default:
                                            msgSent = app.sendTextMessage("Found results");
                                    }
                                });
                            }
                        });
                    });
                    break;
                default:
                    msgSent = Promise.resolve();
                    break;
            }
            return msgSent;
        }
        else {
            return Promise.resolve();
        }
    };
    var completeJourney = function (prediction, journeyDetails) {
        return new Promise(function (resolve, reject) {
            app.analytics.incrementInternal("journey-completed", _.assign({ message: app.data.message }, {
                name: context.journeyName,
                steps: context.steps
            }));
            app.xmppObj = _.assign(app.xmppObj, {
                journeyId: journeyDetails._id,
                journeyName: journeyDetails.name,
                journeySlug: journeyDetails.slug
            });
            if (botMapping && botMapping.skin && botMapping.skin.defaultAutoComplete) {
                app.xmppObj.defaultAutoComplete = botMapping.skin.defaultAutoComplete;
            }
            if (journeyDetails.slug === 'default') {
                // if default step doesnt have answer for orchestrator then app.ask is called again
                if (app.referrer && !app.orchestratorStarted) {
                    if (app.options.enableSuggestion) {
                        var journeys_1 = [];
                        // if confidence of intents in prediction is greater than suggestionConfidence then did you mean is asked
                        Object.keys(app.prediction.intents).forEach(function (key) {
                            if (app.prediction.intents[key] > app.options.suggestionConfidence) {
                                journeys_1.push(key);
                            }
                        });
                        if (journeys_1.length > 0) {
                            app.getMultipleJourneysBySlug(journeys_1).then(function (allJourneys) {
                                var options = [];
                                var suggestionOptions = [];
                                allJourneys.forEach(function (journey) {
                                    options.push({
                                        title: journey.description.replace(/\b\w/g, function (l) { return l.toUpperCase(); }).replace(/_/gi, " "),
                                        text: journey.description.replace(/_/gi, " ")
                                    });
                                    suggestionOptions.push({
                                        slug: journey.slug,
                                        text: journey.description.replace(/_/gi, " ")
                                    });
                                });
                                context.suggestionOptions = suggestionOptions;
                                saveContext();
                                app.sendQuickReplies({
                                    title: app.options.suggestionQuestion,
                                    options: options
                                });
                                resolve();
                            });
                        }
                        else {
                            app.ask(app.referrer);
                            resolve();
                        }
                    }
                    else {
                        app.ask(app.referrer);
                        resolve();
                    }
                    //  below code shouldn't execute and stopping child bots from pushing to unknown utterances
                    return;
                }
                app.log(app.data.message, "unidentified utterance");
                // Add to unidentified list
                if (app.options.saveUnknownMessage === undefined || app.options.saveUnknownMessage) {
                    app.ai.addToUnIdentifiedList(app.data.message, app.sender, app.source, app.profile).then(function () {
                        app.analytics.incrementInternal("unknown-message", { message: app.data.message });
                    }, function () {
                    });
                }
            }
            // Data used for response templates
            var dataProps = {
                source: app.source,
                options: app.options,
                profile: app.profile,
                steps: context.steps,
                data: app.data
            };
            if (journeyDetails.actions && journeyDetails.actions.length > 0) {
                if (app.prediction && app.messageId) {
                    vault.updateMessage(app.messageId, {
                        "slug": context.journeyName + ":response",
                        "data": { "sentiment": app.prediction.sentiment }
                    });
                }
                var sendMessage_1 = function (n) {
                    if (journeyDetails.actions[n]) {
                        var response = journeyDetails.actions[n];
                        if (app.options.targetLanguage && app.options.targetLanguage !== "en" && response.locale && response.locale[app.options.targetLanguage]) {
                            response = response.locale[app.options.targetLanguage];
                            selectMessageType(response, dataProps).then(function () {
                                sendMessage_1(n + 1);
                            });
                        }
                        else if (response.type !== 'func' && app.options.targetLanguage && app.options.targetLanguage !== "en" && !(response.locale && response.locale[app.options.targetLanguage]) && app.options.i18n) {
                            // setting it to false for translating response if its not in db
                            app.options.i18n = false;
                            selectMessageType(response, dataProps).then(function () {
                                // going back to default state
                                app.options.i18n = true;
                                sendMessage_1(n + 1);
                            });
                        }
                        else {
                            selectMessageType(response, dataProps).then(function () {
                                sendMessage_1(n + 1);
                            });
                        }
                    }
                    else {
                        resolve();
                    }
                };
                sendMessage_1(0);
            }
            else {
                app.sendWelcomeMessage(app.options.unknownMessage);
                resolve();
            }
        });
    };
    /**
     *  Processing the action
     * @param prediction
     * @param data data from the user
     * @returns {Promise}
     */
    this.processAction = function (prediction, data) {
        return new Promise(function (resolve, reject) {
            var intent;
            var index = -1;
            if (context && context.suggestionOptions) {
                // if suggestions are there then it is compared with message and if it matches then intent is updated with the particular slug
                if (app.data && app.data.message) {
                    index = _.findIndex(context.suggestionOptions, function (option) {
                        return option.text === app.data.message.toLowerCase();
                    });
                    if (index !== -1) {
                        intent = context.suggestionOptions[index].slug;
                    }
                }
                delete context.suggestionOptions;
                saveContext();
            }
            if (prediction['confidence'] < app.options.minConfidence && (context.complete || context.complete === undefined) && index === -1) {
                intent = 'default';
                context.paramExpected = 'default';
                context.intent = 'default';
                if (botMapping && botMapping.skin && botMapping.skin.defaultAutoComplete) {
                    app.xmppObj.defaultAutoComplete = botMapping.skin.defaultAutoComplete;
                }
            }
            if (intent !== 'default' && index === -1) {
                intent = ((prediction['confidence'] >= app.options.contextConfidence || context.complete || context.complete === undefined)
                    && app.options.intentSwitchExclusions.indexOf(prediction['intent']) === -1 && app.options.excludeParamsForSwitching.indexOf(context.paramExpected) === -1) ? prediction['intent'] : context.intent;
            }
            function performAction(journeyDetails) {
                var promises = [];
                var contextEntitiesIdentified = false;
                delete context.error;
                var originalMessage = app.data.message;
                //if errorQuestion is not defined there then next step is allowed
                var postValidation = function (errorHandler) {
                    return new Promise(function (resolve) {
                        if (!errorHandler) {
                            context.invalidCount = 0;
                            if (!context.steps) {
                                context.steps = {};
                            }
                            if (!context.steps[context.paramExpected]) {
                                context.steps[context.paramExpected] = app.data.message || app.data.location || app.data.file || app.data.image || app.data.audio || app.data.video;
                                if (context['steps'][context.paramExpected]) {
                                    app.analytics.incrementInternal("step-updated", _.assign({ message: app.data.message }, {
                                        journey: context.journeyName,
                                        name: context.paramExpected
                                    }));
                                }
                                else {
                                    app.analytics.incrementInternal("step-recorded", _.assign({ message: app.data.message }, {
                                        journey: context.journeyName,
                                        name: context.paramExpected
                                    }));
                                }
                            }
                            resolve();
                        }
                        else {
                            if (app.options.invalidCount && context.invalidCount >= app.options.invalidCount && app.options.onInvalidCountExceeded) {
                                delete context.invalidCount;
                                app.context = context;
                                app.options.onInvalidCountExceeded();
                                resolve();
                            }
                            else {
                                if (!context.invalidCount) {
                                    context.invalidCount = 1;
                                }
                                else {
                                    context.invalidCount++;
                                }
                                //if type is function then errorHandler is executed otherwise it is sent as text message
                                if (typeof errorHandler === "function") {
                                    var result = errorHandler();
                                    if (result instanceof Promise) {
                                        result.then(function () {
                                            resolve();
                                        });
                                    }
                                    else {
                                        resolve();
                                    }
                                }
                                else {
                                    app.sendTextMessage(errorHandler);
                                    resolve();
                                }
                                app.context = context;
                            }
                        }
                    });
                };
                var afterPostValidation = function () {
                    return new Promise(function (resolve) {
                        nextStep(journeyDetails);
                        //updating the context inside the app object
                        app.context = context;
                        if (!context.complete) {
                            askStep(context, journeyDetails._id)
                                .then(function () {
                                resolve();
                            });
                        }
                        else {
                            // Complete journey
                            completeJourney(prediction, journeyDetails)
                                .then(function () {
                                resolve();
                            });
                        }
                    });
                };
                var promisesArray = [];
                var validateStep = function (stepSlug) {
                    return new Promise(function (resolve) {
                        app.getStepDetails(journeyDetails._id, stepSlug).then(function (stepDetails) {
                            if (!stepDetails) {
                                return resolve({ success: true });
                            }
                            app.xmppObj = _.assign(app.xmppObj, {
                                stepId: stepDetails._id,
                                stepName: stepDetails.name,
                                stepSlug: stepDetails.slug
                            });
                            app.xmppObj.stepAutoComplete = stepDetails.autoComplete;
                            if (prediction.global_model && prediction.global_model.confidence && prediction.global_model.confidence > app.options.secondaryModelConfidence && stepDetails.responses && stepDetails.responses[prediction.global_model.intent] && stepDetails.responses[prediction.global_model.intent].length > 0) {
                                var dataProps_1 = {
                                    source: app.source,
                                    options: app.options,
                                    profile: app.profile,
                                    steps: context.steps,
                                    data: app.data
                                };
                                var sendMessage_2 = function (n) {
                                    if (stepDetails.responses[prediction.global_model.intent][n]) {
                                        var response = stepDetails.responses[prediction.global_model.intent][n];
                                        if (app.options.targetLanguage && app.options.targetLanguage !== "en" && response.locale && response.locale[app.options.targetLanguage]) {
                                            response = response.locale[app.options.targetLanguage];
                                        }
                                        return selectMessageType(response, dataProps_1).then(function () {
                                            sendMessage_2(n + 1);
                                        });
                                    }
                                    else {
                                        resolve({ success: false });
                                    }
                                };
                                sendMessage_2(0);
                            }
                            else {
                                var processValidators_1 = function (n) {
                                    return new Promise(function (resolve, reject) {
                                        if (stepDetails.validators && stepDetails.validators[n]) {
                                            var result = app.functionWrapper(stepDetails.validators[n].func, stepDetails.validators[n].args);
                                            if (result instanceof Promise) {
                                                result.then(function (res) {
                                                    if ((res && res.success) || !res) {
                                                        processValidators_1(n + 1).then(function () {
                                                            resolve();
                                                        }, function (res) {
                                                            return reject(res);
                                                        });
                                                    }
                                                    else {
                                                        return reject(res);
                                                    }
                                                }, function () {
                                                    reject();
                                                });
                                            }
                                            else {
                                                app.log(stepDetails.validators[n].func + " doesn't return a Promise");
                                            }
                                        }
                                        else {
                                            return resolve();
                                        }
                                    });
                                };
                                processValidators_1(0).then(function () {
                                    postValidation(null).then(function () {
                                        return resolve({ success: true });
                                    });
                                }, function (response) {
                                    if (!response) {
                                        return resolve({ success: false });
                                    }
                                    else if (response.customHandler) {
                                        return resolve({ success: false, customHandler: response.customHandler });
                                    }
                                    else {
                                        return resolve({ success: false, errorQuestion: response.question });
                                    }
                                });
                            }
                        });
                    });
                };
                if (Object.keys(prediction.entities).length > 0 && journeyDetails.steps) {
                    var _loop_1 = function (entity) {
                        if (prediction.entities.hasOwnProperty(entity)) {
                            var param_1 = undefined;
                            for (var idx = 0; idx < journeyDetails.steps.length; idx++) {
                                if (journeyDetails.steps[idx].entity === entity) {
                                    if (context.steps) {
                                        //looping through the whole entities to check whether the param is already in the context or not
                                        var allParams = Object.keys(context.steps);
                                        var j = 0;
                                        for (; j < allParams.length; j++) {
                                            if (allParams[j] === journeyDetails.steps[idx].slug) {
                                                break;
                                            }
                                        }
                                        if (j >= allParams.length) {
                                            param_1 = journeyDetails.steps[idx].slug;
                                            break;
                                        }
                                    }
                                    else {
                                        param_1 = journeyDetails.steps[idx].slug;
                                        break;
                                    }
                                }
                            }
                            if (param_1) {
                                contextEntitiesIdentified = true;
                                promisesArray.push(new Promise(function (resolve) {
                                    if (typeof (prediction.entities[entity]) === "string") {
                                        app.data.message = prediction.entities[entity];
                                    }
                                    else {
                                        var value = prediction.entities[entity][0].value;
                                        if (typeof value === "string") {
                                            app.data.message = value;
                                        }
                                        else {
                                            app.data.message = value.value;
                                        }
                                    }
                                    validateStep(param_1).then(function (results) {
                                        resolve(results);
                                    });
                                }));
                            }
                        }
                    };
                    for (var entity in prediction.entities) {
                        _loop_1(entity);
                    }
                }
                if (!contextEntitiesIdentified && context.paramExpected) {
                    if (data) {
                        promisesArray.push(new Promise(function (resolve) {
                            validateStep(context.paramExpected).then(function (results) {
                                resolve(results);
                            });
                        }));
                    }
                }
                var success = true;
                app.q.allSettled(promisesArray).then(function (arrayOfResults) {
                    app.data.message = originalMessage;
                    var allErrorFunctions = [];
                    arrayOfResults.forEach(function (e) {
                        if (e.value && !e.value.success && (e.value.errorQuestion || e.value.customHandler)) {
                            allErrorFunctions.push(function () {
                                return postValidation(e.value.customHandler || e.value.errorQuestion);
                            });
                        }
                        if (e.value && e.value.success === false) {
                            success = false;
                        }
                    });
                    if (allErrorFunctions.length === 0 && success) {
                        afterPostValidation().then(function () {
                            return resolve();
                        });
                    }
                    else if (allErrorFunctions.length !== 0 && !success) {
                        //running all error functions one by one
                        allErrorFunctions.reduce(function (promiseChain, currentTask) {
                            return promiseChain.then(function (chainResults) {
                                return currentTask().then(function (currentResult) {
                                    return chainResults.concat([currentResult]);
                                });
                            });
                        }, Promise.resolve([])).then(function () {
                            return resolve();
                        });
                    }
                    else {
                        return resolve();
                    }
                });
            }
            app.getJourney(intent)
                .then(function (journeyDetails) {
                // No action defined for intent
                context.journeyName = journeyDetails.name;
                context.journeyId = journeyDetails._id;
                app.xmppObj = _.assign(app.xmppObj, {
                    journeyId: journeyDetails._id,
                    journeyName: journeyDetails.name,
                    journeySlug: intent
                });
                if (journeyDetails && journeyDetails.categoryType && app.prediction) {
                    app.prediction.categoryType = journeyDetails.categoryType;
                }
                if ((!journeyDetails || journeyDetails.steps.length === 0) && !journeyDetails.initFunction) {
                    context.complete = true;
                    return completeJourney(prediction, journeyDetails)
                        .then(function () {
                        resolve();
                    });
                }
                // Init function to be called if the context has just switched and didn't start
                // Continue only if this resolves or returns a true
                if (context.intent === intent && context.complete === undefined && journeyDetails.initFunction) {
                    if (app.allFunctions[journeyDetails.initFunction]) {
                        var initResult = app.executeFunction(journeyDetails.initFunction);
                        if (initResult instanceof Promise) {
                            initResult.then(function () {
                                performAction(journeyDetails);
                            }, function () {
                                resolve();
                            });
                        }
                        else if (initResult) {
                            performAction(journeyDetails);
                        }
                    }
                    else {
                        performAction(journeyDetails);
                    }
                }
                else {
                    performAction(journeyDetails);
                }
            }, function () {
                return completeJourney(prediction, undefined)
                    .then(function () {
                    context.complete = true;
                    resolve();
                });
            });
        });
    };
    var askStep = function (context, journeyId) {
        return new Promise(function (resolve) {
            if (app.prediction && app.messageId) {
                vault.updateMessage(app.messageId, {
                    "slug": context.journeyName + ":" + context.paramExpected,
                    "data": { "sentiment": app.prediction.sentiment }
                });
            }
            app.getStepDetails(journeyId, context.paramExpected).then(function (stepDetails) {
                app.xmppObj = _.assign(app.xmppObj, {
                    stepId: stepDetails._id,
                    stepName: stepDetails.name,
                    stepSlug: stepDetails.slug
                });
                var dataProps = {
                    source: app.source,
                    options: app.options,
                    profile: app.profile,
                    steps: context.steps,
                    data: app.data
                };
                app.xmppObj.stepId = stepDetails._id;
                app.xmppObj.stepName = stepDetails.name;
                app.xmppObj.stepSlug = stepDetails.slug;
                app.xmppObj.stepAutoComplete = stepDetails.autoComplete;
                var sendMessage = function (n) {
                    if (stepDetails.prompts && stepDetails.prompts[n]) {
                        var response = stepDetails.prompts[n];
                        if (app.options.targetLanguage && app.options.targetLanguage !== "en" && response.locale && response.locale[app.options.targetLanguage]) {
                            response = response.locale[app.options.targetLanguage];
                            return selectMessageType(response, dataProps).then(function () {
                                sendMessage(n + 1);
                            });
                        }
                        else if (response.type !== 'func' && app.options.targetLanguage && app.options.targetLanguage !== "en" && !(response.locale && response.locale[app.options.targetLanguage]) && app.options.i18n) {
                            // setting it to false for translating response if its not in db
                            app.options.i18n = false;
                            return selectMessageType(response, dataProps).then(function () {
                                // going back to default state
                                app.options.i18n = true;
                                sendMessage(n + 1);
                            });
                        }
                        else {
                            return selectMessageType(response, dataProps).then(function () {
                                sendMessage(n + 1);
                            });
                        }
                    }
                    else {
                        resolve();
                    }
                };
                sendMessage(0);
            });
        });
    };
    var generateOptions = function (optionString) {
        var dataProps = { source: app.source, options: app.options, profile: app.profile, params: context.steps };
        var options = [];
        var optionsBroken = optionString.split(",");
        for (var i = 0; i < optionsBroken.length; i++) {
            var option = optionsBroken[i].split("::");
            if (option.length > 1) {
                var title = app.mustache.render(option[0], dataProps);
                var text = app.mustache.render(option[1] || option[0], dataProps);
                options.push({ title: title, text: text, primary: !!option[2], image: option[3] });
            }
            else {
                var option_1 = optionsBroken[i].split(":");
                var title = app.mustache.render(option_1[0], dataProps);
                var text = app.mustache.render(option_1[1] || option_1[0], dataProps);
                options.push({ title: title, text: text, primary: !!option_1[2], image: option_1[3] });
            }
        }
        return options;
    };
    var saveContext = function () {
        return app.memory.set("context", JSON.stringify(context));
    };
    this.saveMessage = function () {
        try {
            if (!context.dataHistory) {
                context.dataHistory = [];
            }
            context.dataHistory.push({
                data: app.data,
                intent: app.prediction ? app.prediction['intent'] : "",
                confidence: app.prediction ? app.prediction['confidence'] : 1
            });
            context.dataHistory = context.dataHistory.splice(-1 * 5);
        }
        catch (e) {
        }
        saveContext();
    };
    // Get the context
    this.getContext = function () {
        return new Promise(function (resolve, reject) {
            loadContext().then(function () {
                resolve(context);
            });
        });
    };
    this.resetContext = function (contextData) {
        context = contextData;
        app.context = contextData;
        return saveContext();
    };
    // Start the form
    this.changeJourney = function (prediction, data) {
        return new Promise(function (resolve, reject) {
            loadContext().then(function () {
                // Clear the context
                self.clearContext();
                context.intent = prediction['intent'];
                saveContext();
                self.processAction(prediction, data).then(function () {
                    // context.complete is checked to handle cases where in complete action trigger intent is used
                    if (context.complete) {
                        self.clearContext().then(function () {
                            resolve(context);
                        });
                    }
                    else {
                        saveContext();
                        resolve(context);
                    }
                }, function () {
                    reject("No action");
                });
            });
        });
    };
    //  Context params to be cleared
    this.clearContext = function () {
        //TODO Save the old context for a recall
        if (!context.history) {
            context.history = [];
        }
        if (context.intent) {
            context.history.push({
                intent: context.intent,
                complete: context.complete,
                steps: _.cloneDeep(context.steps)
            });
            // Store only last 10 intents in the memory
            context.history = context.history.splice(-1 * 5);
        }
        // Store the previous entities as well
        delete context.paramExpected;
        delete context.question;
        delete context.options;
        delete context.steps;
        delete context.complete;
        delete context.invalidCount;
        delete context.intent;
        delete context.journeyName;
        delete context.journeyId;
        delete context.stepId;
        app.context = context;
        return saveContext();
    };
    this.setContextParam = function (entity, value) {
        if (!context) {
            loadContext().then(function () {
                if (!context.steps) {
                    context.steps = {};
                }
                if (context['steps'][entity]) {
                    app.analytics.incrementInternal("step-updated", _.assign({ message: value }, {
                        journey: context.journeyName,
                        name: entity
                    }));
                }
                else {
                    app.analytics.incrementInternal("step-recorded", _.assign({ message: value }, {
                        journey: context.journeyName,
                        name: entity
                    }));
                }
                context.steps[entity] = value;
                app.context = context;
                return saveContext();
            });
        }
        else {
            if (!context.steps) {
                context.steps = {};
            }
            if (context['steps'][entity]) {
                app.analytics.incrementInternal("step-updated", _.assign({ message: value }, {
                    journey: context.journeyName,
                    name: entity
                }));
            }
            else {
                app.analytics.incrementInternal("step-recorded", _.assign({ message: value }, {
                    journey: context.journeyName,
                    name: entity
                }));
            }
            context.steps[entity] = value;
            app.context = context;
            return saveContext();
        }
    };
    this.setContextMultiple = function (paramObject) {
        if (paramObject && typeof (paramObject) === 'object' && !(paramObject instanceof Array) && !(paramObject instanceof Date)) {
            if (!context) {
                return loadContext().then(function () {
                    if (!context.steps) {
                        context.steps = {};
                    }
                    Object.keys(paramObject).forEach(function (key) {
                        if (context['steps'][key]) {
                            app.analytics.incrementInternal("step-updated", _.assign({ message: paramObject[key] }, {
                                journey: context.journeyName,
                                name: key
                            }));
                        }
                        else {
                            app.analytics.incrementInternal("step-recorded", _.assign({ message: paramObject[key] }, {
                                journey: context.journeyName,
                                name: key
                            }));
                        }
                        context['steps'][key] = paramObject[key];
                    });
                    app.context = context;
                    return saveContext();
                });
            }
            else {
                if (!context.steps) {
                    context.steps = {};
                }
                Object.keys(paramObject).forEach(function (key) {
                    if (context['steps'][key]) {
                        app.analytics.incrementInternal("step-updated", _.assign({ message: paramObject[key] }, {
                            journey: context.journeyName,
                            name: key
                        }));
                    }
                    else {
                        app.analytics.incrementInternal("step-recorded", _.assign({ message: paramObject[key] }, {
                            journey: context.journeyName,
                            name: key
                        }));
                    }
                    context['steps'][key] = paramObject[key];
                });
                app.context = context;
                return saveContext();
            }
        }
        else {
            app.log('insert only objects');
        }
    };
    this.deleteContextParam = function (entity, value) {
        if (!context) {
            return loadContext().then(function () {
                if (context.steps && context.steps[entity]) {
                    delete context.steps[entity];
                }
                app.context = context;
                return saveContext();
            });
        }
        else {
            if (context.steps && context.steps[entity]) {
                delete context.steps[entity];
            }
            app.context = context;
            return saveContext();
        }
    };
    // Process Context
    this.process = function (prediction, data) {
        return new Promise(function (resolve, reject) {
            loadContext().then(function () {
                // Process and resolve
                self.processAction(prediction, data).then(function () {
                    if (context.complete) {
                        self.clearContext().then(function () {
                            resolve(context);
                        });
                    }
                    else {
                        app.processEndTime = new Date();
                        saveContext();
                        resolve(context);
                    }
                });
            }, function (e) {
                reject(e);
            });
        });
    };
};
var functions = {};
exports.functions = functions;
var App = /** @class */ (function () {
    function App(options) {
        var _this = this;
        //This function will give you a encrypted logs link to the current user.
        this.getMessageLogUrl = function () {
            return 'https://app.yellowmessenger.com/#/public/messages/' + encrypt(_this.bot + "&&" + _this.sender + "&&" + _this.source);
        };
        this.getSessionMessageLogUrl = function () {
            var token = encrypt(_this.bot + "&&" + _this.sender + "&&" + _this.source);
            return "https://app.yellowmessenger.com/#/public/messages/" + token + "/" + _this.sessionId;
        };
        this.getTimeStampMessagesLogUrl = function (startTime, endTime) {
            var token = encrypt(_this.bot + "&&" + _this.sender + "&&" + startTime + "&&" + endTime);
            return "https://app.yellowmessenger.com/#/public/messages/" + token + "/timestamp";
        };
        this.encrypt = encrypt;
        this.decrypt = decrypt;
        this.knowledge = knowledge;
        this.sendEmail = mailer.sendEmail;
        this.getJourney = function (intent) {
            return actionLib.getJourney(intent, _this.bot);
        };
        this.getStepDetails = function (intent, slug) {
            return actionLib.getStep(intent, slug, _this.bot);
        };
        this.getMultipleJourneysBySlug = function (journeySlugs) {
            return actionLib.getMultipleJourneysBySlug(journeySlugs, _this.bot);
        };
        this.getMultipleJourneysByCategoryType = function (categoryType) {
            return _this.dataStore.search({
                table: "alljourneys",
                body: {
                    query: {
                        match: {
                            categoryType: categoryType
                        }
                    }
                }
            }).then(function (results) {
                return Promise.resolve(results.hits.total > 0 ? _.map(_.filter(results.hits.hits, function (hit) {
                    return hit._source.categoryType.toLowerCase() === categoryType.toLowerCase();
                }), function (hit) {
                    return {
                        name: hit._source.name,
                        description: hit._source.description,
                        categoryType: hit._source.categoryType,
                        slug: hit._source.slug
                    };
                }) : []);
            }, function (error) {
                return Promise.reject(error);
            });
        };
        this.actions = {};
        this.getFile = function (url) {
            var self = this;
            return new Promise(function (resolve, reject) {
                self.fileRequest.get(url, function (error, response, body) {
                    if (!error && response.statusCode === 200) {
                        resolve(new Buffer(body));
                    }
                    else {
                        reject(error);
                    }
                });
            });
        };
        this.request = request;
        this.requestretry = requestretry;
        this.executeFunction = function (funcName, args, defaultPrompt) {
            return new Promise(function (resolve) {
                var self = _this;
                if (_this.runDefaultFunction && defaultPrompt) {
                    self.functionWrapper(funcName, args).then(function () {
                        self.publishInternal(true, 'success', {
                            'messageArray': self.messageArray
                        });
                        return resolve();
                    }, function (error) {
                        return resolve();
                    });
                }
                else {
                    self.functionWrapper(funcName, args).then(function () {
                        return resolve();
                    }, function (error) {
                        return resolve();
                    });
                }
            });
        };
        this.functionWrapper = function (funcName, args) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var startTime = new Date();
                return self.allFunctions[funcName](self, args).then(function (data) {
                    resolve(data);
                }, function (err) {
                    reject(err);
                })["finally"](function () {
                    var endTime = new Date();
                    self.analytics.incrementInternal("function-execution-time", {
                        name: funcName,
                        args: args
                    }, endTime.getTime() - startTime.getTime());
                });
            });
        };
        this.updateProfile = function () {
            var self = _this;
            return new Promise(function (resolve, reject) {
                vault.saveOrUpdateProfile(self.sender, self.bot, self.source, self.profile);
                if (self.profile.name !== self.profileOriginal.name && self.profile.name !== undefined) {
                    vault.updateVaultLogName(self.sender, self.bot, self.source, self.profile.name).then(function (vaultLog) {
                        return resolve(vaultLog);
                    }, function (message) {
                        return reject(message);
                    });
                }
            });
        };
        this.updateProfileName = function (newName) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var nameSplit = newName.split(' ');
                var firstName, lastName, data;
                firstName = nameSplit[0];
                if (nameSplit.length > 1) {
                    lastName = nameSplit.slice(1).join(' ');
                }
                if (self.profile) {
                    self.profile.first_name = firstName;
                    self.profile.last_name = lastName || '';
                    self.profile.name = newName;
                }
                else {
                    self.profile = {
                        name: newName,
                        first_name: firstName,
                        last_name: lastName || ''
                    };
                }
                vault.saveOrUpdateProfile(self.sender, self.bot, self.source, self.profile);
                vault.updateVaultLogName(self.sender, self.bot, self.source, newName).then(function (vaultLog) {
                    return resolve(vaultLog);
                }, function (message) {
                    return reject(message);
                });
            });
        };
        this.setActionFunctions = function (actionFunctions) {
            _this.actions = actionFunctions;
        };
        // Send & Save Email on the Database
        this.sendEmailMessage = function (email) {
            emailSender.sendMessage(_this.sender, {
                email: email
            }, _this.bot, function () {
            });
        };
        this.wordToNumber = function (message) {
            return wordToNumber.getNumber(message);
        };
        this.getphonetics = phonetics.getPhonetics;
        this.machineComprehension = machineComprehension;
        this.searchDocuments = function (message, functionScore) {
            return new Promise(function (resolve) {
                request({
                    url: "http://documents:7788/documents/search-internal?bot=" + _this.bot + "&query=" + message + "&functionScore=" + (functionScore || false),
                    method: 'GET',
                    json: true
                }, function (err, resp, body) {
                    resolve(body);
                });
            });
        };
        this.fetchDocument = function (documentId) {
            return new Promise(function (resolve) {
                request({
                    url: "http://documents:7788/documents/document/" + documentId + "?bot=" + _this.bot,
                    method: 'GET',
                    json: true
                }, function (err, resp, body) {
                    resolve(body);
                });
            });
        };
        this.documentUrl = function (documentPath) {
            return new Promise(function (resolve) {
                request({
                    url: "http://documents:7788/documents/file-internal/" + documentPath + "?bot=" + _this.bot,
                    method: 'GET',
                    json: true
                }, function (err, resp, body) {
                    resolve(body);
                });
            });
        };
        // Send OTP
        this.otp = require('./utils/otp');
        this.sendOtp = function (number) {
            return _this.otp.sendOtp(number, _this.memory.set);
        };
        this.verifyOtp = function (otpTyped) {
            return _this.otp.verifyOtp(otpTyped, _this.memory.get);
        };
        this.delayedMessage = function (event, data, delay, callback) {
            var self = _this;
            setTimeout(function () {
                rabbit.publishInternal(JSON.stringify({
                    sender: self.sender,
                    source: self.source,
                    business: self.botIdentifier,
                    event: event,
                    data: data
                }), 'delayed-message-queue', callback);
            }, delay);
        };
        this.renderTemplate = function (text, data) {
            return mustache.render(text, data);
        };
        this.extractName = function (sentence) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var capitalisedSentence = sentence.replace(/\b\w/g, function (l) { return l.toUpperCase(); });
                self.ai.predict(capitalisedSentence).then(function (result) {
                    if (typeof result === 'string') {
                        result = JSON.parse(result);
                    }
                    if (result.parser && result.parser.noun_chunks && result.parser.noun_chunks.length > 0) {
                        for (var i = 0; i < result.parser.noun_chunks.length; i++) {
                            var chunk = result.parser.noun_chunks[i];
                            if (chunk.pos && chunk.pos === 'PROPN') {
                                return resolve(chunk.chunk);
                            }
                        }
                        return reject(new Error('No name found'));
                    }
                    else {
                        return reject(new Error('No name found'));
                    }
                });
            });
        };
        this.checkContext = function () {
            var self = _this;
            return new Promise(function (resolve, reject) {
                self.contextProcessor.getContext().then(function (context) {
                    self.contextEndTime = new Date();
                    // Predict it
                    self.context = context;
                    self.predict(context.intent && context.core ? context.intent : "")
                        .then(function (prediction) {
                        if (prediction['intent'] === 'none') {
                            prediction['intent'] = 'default';
                        }
                        self.predictionEndTime = new Date();
                        var AUTHENTICATE_TRUE = true;
                        var AUTHENTICATE_FALSE = false;
                        var RUNPROCESS_TRUE = true;
                        var RUNPROCESS_FALSE = false;
                        var processWithAuthentication = function (authenticate, runprocess) {
                            /*
                                if runprocess then contextProcessor.process is called else contextProcessor.changeJourney is called
                                the authentication function is run only when authenticate is true
                                if authentication function is resolved then the user is authorized
                                if authentication function is rejected then the user is not authorized
                            */
                            if (authenticate) {
                                if (runprocess) {
                                    self.options.authentication(context).then(function () {
                                        self.contextProcessor.process(prediction, self.data)
                                            .then(function (context) {
                                            resolve(context);
                                        });
                                    }, function () {
                                        return resolve(context);
                                    });
                                }
                                else {
                                    self.options.authentication(context).then(function () {
                                        self.contextProcessor.changeJourney(prediction, self.data)
                                            .then(function (context) {
                                            resolve(context);
                                        });
                                    }, function () {
                                        return resolve(context);
                                    });
                                }
                            }
                            else {
                                if (runprocess) {
                                    self.contextProcessor.process(prediction, self.data)
                                        .then(function (context) {
                                        resolve(context);
                                    });
                                }
                                else {
                                    self.contextProcessor.changeJourney(prediction, self.data)
                                        .then(function (context) {
                                        resolve(context);
                                    });
                                }
                            }
                        };
                        if (self.options['entities']) {
                            prediction['entities'] = _.assign(prediction['entities'], self.options['entities']);
                        }
                        self.prediction = prediction;
                        self.contextProcessor.saveMessage();
                        // Reset context only if journey is switched
                        if (!context.intent
                            || (context.intent !== prediction['intent'] && prediction['confidence'] >= self.options.contextConfidence && (!self.options.intentSwitchExclusions || self.options.intentSwitchExclusions.indexOf(prediction['intent']) === -1) && self.options.excludeParamsForSwitching.indexOf(context.paramExpected) === -1)
                            || (context.intent !== prediction['intent'] && prediction['confidence'] >= self.options.minConfidence && (context.complete === undefined || context.complete))
                            || (prediction['confidence'] >= self.options.minConfidence && context.intent === 'default')) {
                            // if no intents are given in auth options then all intents are authorized
                            if (self.options.authOptions.intents.length === 0) {
                                processWithAuthentication(AUTHENTICATE_TRUE, RUNPROCESS_FALSE);
                            }
                            else {
                                var j = 0;
                                for (; j < self.options.authOptions.intents.length; j++) {
                                    if (self.options.authOptions.intents[j] === prediction['intent']) {
                                        break;
                                    }
                                }
                                // if intents is not there in authentication then authentication function is not called
                                if (j >= self.options.authOptions.intents.length) {
                                    processWithAuthentication(AUTHENTICATE_FALSE, RUNPROCESS_FALSE);
                                }
                                else {
                                    processWithAuthentication(AUTHENTICATE_TRUE, RUNPROCESS_FALSE);
                                }
                            }
                        }
                        else {
                            processWithAuthentication(AUTHENTICATE_FALSE, RUNPROCESS_TRUE);
                        }
                    }, function () {
                        self.contextProcessor.saveMessage();
                        if (context.intent) {
                            self.contextProcessor.process({
                                intent: context.intent,
                                confidence: 1,
                                entities: []
                            }, self.data)
                                .then(function (context) {
                                resolve(context);
                            });
                        }
                    });
                });
            });
        };
        this.customEntityRecognizer = undefined;
        this.predict = function (context) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.data.message) {
                    if (self.options.targetLanguage && self.options.targetLanguage !== 'en' && self.options.translateInputMessages === true) {
                        translateClient.translate(self.data.message, {
                            to: 'en',
                            from: self.options.targetLanguage
                        }, function (err, translation) {
                            self.data.message = translation;
                            self.ai.predict(self.data.message, self.options.enableContextForPrediction ? context : "", self.options.entityThreshold, self.options.spellCorrection, self.options.excludeKeywordsForPrediction).then(function (prediction) {
                                if (self.customEntityRecognizer) {
                                    var result = self.customEntityRecognizer(prediction);
                                    if (result instanceof Promise) {
                                        result.then(function (recognizerResult) {
                                            resolve(recognizerResult || prediction);
                                        });
                                    }
                                    else {
                                        resolve(result || prediction);
                                    }
                                }
                                else {
                                    resolve(prediction);
                                }
                            }, function () {
                                console.log("Timed out for bot : " + self.bot + " with text: " + (self.data.message || "no_text") + " sender: " + self.sender);
                            });
                        });
                    }
                    else {
                        self.ai.predict(self.data.message, self.options.enableContextForPrediction ? context : "", self.options.entityThreshold, self.options.spellCorrection, self.options.excludeKeywordsForPrediction).then(function (prediction) {
                            if (self.customEntityRecognizer) {
                                var result = self.customEntityRecognizer(prediction);
                                if (result instanceof Promise) {
                                    result.then(function () {
                                        resolve(prediction);
                                    });
                                }
                                else {
                                    resolve(prediction);
                                }
                            }
                            else {
                                resolve(prediction);
                            }
                        }, function () {
                            console.log("Timed out for bot : " + self.bot + " with text: " + (self.data.message || "no_text") + " sender: " + self.sender);
                        });
                    }
                }
                else {
                    reject();
                }
            });
        };
        this.entityValidators = {};
        this.options = {
            minConfidence: .85,
            contextConfidence: 0.90,
            entityThreshold: 0.96,
            suggestionConfidence: 0.65,
            suggestionQuestion: 'Did you mean ?',
            enableSuggestion: false,
            unknownMessage: "I think you are looking for something I cannot help you with.",
            transferToAgent: false,
            transferToAgentMessage: 'I am unable to help you with your query at the moment but I can transfer our conversation to my human friend who can help you out.',
            targetLanguage: 'en',
            autoResponse: true,
            spellCorrection: true,
            intentSwitchExclusions: [],
            secondaryModelConfidence: 0.84,
            FAQQuery: "",
            i18n: false,
            onInvalidCountExceeded: function () {
            },
            //authentication function which takes array of intents. reject if user is not authorized and resolve if user is authorized
            authentication: function (context) {
                return new Promise(function (resolve, reject) {
                    return resolve();
                });
            },
            /*authorization options type is custom for custom authentication by default it is set to custom authentication
            intents should be mentioned for which the authentication function should run. if no intents are given then by default all intents will be authorized
            if faq is set true then all faqs are authorized by default it is assumed true*/
            authOptions: {
                "type": "custom",
                "intents": [],
                "faq": true
            },
            shouldFAQSessionEnd: true,
            enableContextForPrediction: false,
            excludeKeywordsForPrediction: [],
            faqInit: function (context) {
                return new Promise(function (resolve, reject) {
                    resolve();
                });
            },
            excludeParamsForSwitching: [],
            translateInputMessages: true // a variable to for not translating input messages
        };
        this.setTargetLanguage = function (targetLanguage) {
            _this.options.targetLanguage = targetLanguage;
        };
        this.clearContext = function () {
            _this.contextProcessor.clearContext();
            if (_this.orchestrator) {
                _this.orchestrator.clearContext();
            }
        };
        this.pauseBot = function (expiry) {
            return botHelper.pauseBot(_this.bot, _this.sender, _this.source, expiry);
        };
        this.unPauseBot = function () {
            return botHelper.unPauseBot(_this.bot, _this.sender, _this.source);
        };
        this.isBotPaused = function () {
            return botHelper.isBotPaused(_this.bot, _this.sender, _this.source);
        };
        this.ask = function (botId, data) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (botId !== self.bot) {
                    rabbit.publishInternal(JSON.stringify({
                        sender: self.sender,
                        source: self.source,
                        business: botId,
                        data: data || self.data,
                        referrer: self.bot,
                        orchestratorBotId: self.orchestratorStarted ? self.bot : undefined
                    }), 'delayed-message-queue', resolve);
                    // Please don't uncomment this or delete this.
                    //  request({
                    //     url: 'http://127.0.0.1:8080/yellowmessenger/receive',
                    //     method: 'POST',
                    //     json: {
                    //         bot: botId,
                    //         from: sender,
                    //         message: JSON.stringify(data||self.data),
                    //         referrer: bot,
                    //         orchestratorBotId: self.orchestratorStarted ? bot:undefined
                    //     }
                    // }, function(err,resp,body){
                    //     console.log(body);
                    // });
                }
                else {
                    reject("Cannot call the same bot");
                }
            });
        };
        this.logTimes = function () {
            var self = _this;
            try {
                var current = new Date();
                if (self.execStartTime) {
                    var times = {
                        total: current.getTime() - self.execStartTime.getTime()
                    };
                    if (self.libraryStartTime) {
                        times['libraryStart'] = current.getTime() - self.libraryStartTime.getTime();
                    }
                    if (self.contextEndTime) {
                        times['contextEndTime'] = current.getTime() - self.contextEndTime.getTime();
                    }
                    if (self.predictionEndTime) {
                        times['predictionEndTime'] = current.getTime() - self.predictionEndTime.getTime();
                    }
                    if (self.processEndTime) {
                        times['processEndTime'] = current.getTime() - self.processEndTime.getTime();
                    }
                    self.log(times);
                }
            }
            catch (e) {
            }
        };
        this.spellCheck = function (message) {
            return new Promise(function (resolve) {
                var options = {
                    method: 'POST',
                    url: 'https://api.cognitive.microsoft.com/bing/v7.0/spellcheck',
                    qs: { mode: 'spell' },
                    headers: {
                        'ocp-apim-subscription-key': '5aacb252a530441a9bd9881f450459b9',
                        'content-type': 'application/x-www-form-urlencoded'
                    },
                    form: { Text: message }
                };
                request(options, function (error, response, body) {
                    try {
                        body = JSON.parse(body);
                    }
                    catch (e) {
                        // Do Nothing
                    }
                    if (response.statusCode === 200 || response.statusCode === '200') {
                        if (body && body.flaggedTokens && body.flaggedTokens.length > 0) {
                            var correctedWords = body.flaggedTokens;
                            var correctedMessage_1 = message;
                            _.forEach(correctedWords, function (c) {
                                try {
                                    var regex = new RegExp(c.token, "g");
                                    correctedMessage_1 = _.replace(correctedMessage_1, regex, c.suggestions[0].suggestion);
                                }
                                catch (e) {
                                }
                            });
                            return resolve({
                                success: true,
                                message: message,
                                correctedMessage: correctedMessage_1
                            });
                        }
                    }
                    return resolve({
                        success: false,
                        message: message
                    });
                });
            });
        };
        this.execCount = 0;
        this.start = function (options) {
            var self = _this;
            self.execCount++;
            if (self.execCount >= 3) {
                return new Promise(function (resolve) {
                    resolve();
                });
            }
            self.libraryStartTime = new Date();
            return new Promise(function (resolve) {
                // passing the targetLanguage to xmpp object
                self.xmppObj.targetLanguage = options && options.targetLanguage ? options.targetLanguage : 'en';
                if (options) {
                    self.options = _.assign(self.options, options);
                }
                if (self.data.event && self.data.event.code && self.data.event.code.indexOf("ym_") === 0) {
                    self.logTimes();
                    return resolve();
                }
                self.checkContext().then(function () {
                    if (self.source === 'googleAssistant') {
                        self.publishInternal(true, 'success', {
                            'messageArray': self.messageArray,
                            'conversationId': self.googleConversationId,
                            'surfaceCapalibilities': self.googleSurfaceCapabilities
                        });
                        self.logTimes();
                        resolve();
                    }
                    else if (self.source === 'voice') {
                        self.publishInternal(true, 'success', {
                            'messageArray': self.messageArray
                        });
                        self.logTimes();
                        resolve();
                    }
                    else {
                        self.logTimes();
                        resolve();
                    }
                });
            });
        };
        this.publish = function (messages) {
            _this.publishInternal(true, 'success', {
                'messageArray': messages
            });
        };
        this.triggerIntent = function (intent, entities, params) {
            var self = _this;
            return new Promise(function (resolve) {
                self.contextProcessor.getContext().then(function (context) {
                    var prediction = {
                        confidence: 1,
                        intent: intent,
                        entities: _.mapValues(entities || {}, function (val, key) {
                            var values = [];
                            if (!(val instanceof Array)) {
                                val = [val];
                            }
                            for (var i = 0; i < val.length; i++) {
                                values.push({
                                    text: val[i],
                                    value: val[i]
                                });
                            }
                            return values;
                        })
                    };
                    self.prediction = prediction;
                    if (params && typeof (params) === 'object' && !(params instanceof Array) && !(params instanceof Date)) {
                        delete context.paramExpected;
                        delete context.question;
                        delete context.options;
                        delete context.questionOptions;
                        delete context.questionFunction;
                        delete context.complete;
                        delete context.invalidCount;
                        context.steps = {};
                        Object.keys(params).forEach(function (key) {
                            context['steps'][key] = params[key];
                        });
                        context.intent = prediction['intent'];
                        self.context = context;
                        self.contextProcessor.processAction(prediction).then(function () {
                            self.contextProcessor.resetContext(context);
                            resolve(context);
                        });
                    }
                    else {
                        self.contextProcessor.changeJourney(prediction)
                            .then(function (context) {
                            resolve(context);
                        });
                    }
                });
            });
        };
        this.invokeJourney = this.triggerIntent;
        this.getProfile = function () {
            return _this.options['profile'];
        };
        this.saveAdditionalDataToMessage = function (dataToAttached) {
            return Promise.resolve();
        };
        //TODO - Deprecate once updated in BAGIC
        this.createTicket = function (issue, contact, route, manualAssignment) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var data = {
                    botId: self.bot,
                    source: self.source,
                    userId: self.sender,
                    issue: issue,
                    contact: contact
                };
                agents.createTicket(self.mapping, route, data, manualAssignment).then(function (assignedData) {
                    return resolve(assignedData);
                }, function (err) {
                    return reject(err);
                });
            });
        };
        this.raiseTicket = function (ticketOptions) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (!ticketOptions.contact && !ticketOptions.contact.name && !ticketOptions.contact.phone && !ticketOptions.contact.email) {
                    return reject({
                        Error: 'Email, Phone and Email are mandatory',
                        Usage: "contact: {\n                                name: Yellow Messenger\n                                email: test@yellowmessenger.com\n                                phone: 9898989898"
                    });
                }
                if (!ticketOptions.issue) {
                    return reject({
                        Error: 'Issue title and description is mandatory',
                        Usage: "issue: description of issue"
                    });
                }
                var category = ticketOptions.category; // eg. ['sales']
                var contact = ticketOptions.contact; // { email: test@yellowmessenger.com, phone: 9898989898, name: 'Yellow Messenger' }
                var priority = ticketOptions.priority; // 'LOW/'MEDIUM'/'HIGH'
                var severity = ticketOptions.severity; // 'LOW/'MEDIUM'/'HIGH'
                var tags = ticketOptions.tags;
                var issue = ticketOptions.issue;
                var requestObj = {
                    botId: self.bot,
                    uid: self.sender,
                    source: self.source,
                    issue: issue,
                    category: category,
                    priority: priority,
                    severity: severity,
                    tags: tags,
                    contact: contact
                };
                if (self.maximumAssignedCount !== undefined) {
                    requestObj['maximumAssignedCount'] = self.maximumAssignedCount;
                }
                agentsInstance.post('/tickets/internal/create', requestObj).then(function (response) {
                    var ticketData = response.data.data;
                    if (ticketData && ticketData.assignedTo) {
                        self.pauseBot(undefined);
                        return resolve(ticketData);
                    }
                    else {
                        return resolve(ticketData);
                    }
                }, function (error) {
                    return reject(error);
                });
            });
        };
        this.agentsAvailable = function () {
            var self = _this;
            return new Promise(function (resolve, reject) {
                agentsInstance.post('/tickets/internal/agents-available', {
                    botId: self.bot
                }).then(function (response) {
                    if (response.data.success) {
                        return resolve();
                    }
                    else {
                        return reject();
                    }
                }, function (error) {
                    return reject(error);
                });
            });
        };
        this.agentsOnline = this.agentsAvailable;
        this.renderMessage = function (code, data, defaultMessage) {
            var self = _this;
            var message = (self.options.targetLanguage && self.options.targetLanguage !== "en" ? self.mapping.configMessagesLocale[self.options.targetLanguage][code] : null)
                || self.mapping.configMessages[code] || config.messages[code] || defaultMessage || "Message not found with code " + code;
            return mustache.render(message.replace(/\\\\n/g, "\n"), data || {});
        };
        this.sendWelcomeMessage = function (msg, paramOptions) {
            var self = _this;
            var externalMessage = false;
            if (msg && msg.length > 0) {
                externalMessage = true;
            }
            var message = msg || self.mapping.welcomeMessage;
            if (!message) {
                message = "Hello!";
            }
            if (self.mapping.welcomeMessages && self.mapping.welcomeMessages.length > 0) {
                if (externalMessage) {
                    // Check for Quick Replies or Cards as the last message and send it with the current Message;
                    var cards_1 = _.filter(self.mapping.welcomeMessages, function (w) {
                        if (w.type === "Cards") {
                            return w;
                        }
                    });
                    var quickReplies = _.filter(self.mapping.welcomeMessages, function (w) {
                        if (w.type === "QuickReplies") {
                            return w;
                        }
                    });
                    if (quickReplies && quickReplies.length > 0) {
                        if (self.options.targetLanguage && self.options.targetLanguage !== "en" && quickReplies[0].locale && quickReplies[0].locale[self.options.targetLanguage]) {
                            quickReplies[0] = quickReplies[0].locale[self.options.targetLanguage];
                        }
                        return self.sendQuickReplies({
                            title: message,
                            options: quickReplies[0].quickReplies.options
                        }, paramOptions);
                    }
                    else if (cards_1 && cards_1.length > 0) {
                        if (self.options.targetLanguage && self.options.targetLanguage !== "en" && cards_1[0].locale && cards_1[0].locale[self.options.targetLanguage]) {
                            cards_1[0] = cards_1[0].locale[self.options.targetLanguage];
                        }
                        return self.sendTextMessage(message, {}).then(function () {
                            self.sendCards(cards_1[0].cards, paramOptions, {});
                        }, paramOptions);
                    }
                    else {
                        return self.sendTextMessage(message, paramOptions);
                    }
                }
                var welcomeMessage = self.mapping.welcomeMessages[0];
                if (self.options.targetLanguage && self.options.targetLanguage !== "en" && welcomeMessage.locale && welcomeMessage.locale[self.options.targetLanguage]) {
                    welcomeMessage = welcomeMessage.locale[self.options.targetLanguage];
                }
                if (welcomeMessage.hideInput) {
                    if (!paramOptions) {
                        paramOptions = {};
                    }
                    paramOptions.hideInput = true;
                }
                if (welcomeMessage.type === "Message") {
                    if (msg) {
                        return self.sendTextMessage(msg, paramOptions);
                    }
                }
                if (welcomeMessage.type === "QuickReplies") {
                    if (msg) {
                        welcomeMessage.quickReplies.title = msg;
                    }
                    return self.sendQuickReplies(welcomeMessage.quickReplies, paramOptions);
                }
                if (welcomeMessage.type === "Image") {
                    return self.sendImage(welcomeMessage.image);
                }
                if (welcomeMessage.type === "Email") {
                    var to_2 = welcomeMessage.to;
                    var subject_2 = welcomeMessage.subject;
                    var body_2 = welcomeMessage.body;
                    return new Promise(function (resolve, reject) {
                        mailer.sendEmail(to_2, subject_2, body_2, {}, '', '');
                        resolve();
                    });
                }
                if (welcomeMessage.type === "Video") {
                    return self.sendVideo({ url: welcomeMessage.url });
                }
                if (welcomeMessage.type === "Cards") {
                    if (msg) {
                        welcomeMessage.cards[0].text = msg;
                    }
                    return self.sendCards(welcomeMessage.cards, paramOptions, {});
                }
                return;
            }
            if (self.mapping.welcomeOptions && self.mapping.welcomeOptions.options) {
                var options = _.map(self.mapping.welcomeOptions.options, function (o) {
                    o.title = o.label;
                    o.text = o.value;
                    return o;
                });
                return self.sendQuickReplies({ title: message, options: options }, paramOptions);
            }
            else {
                return self.sendTextMessage(message, paramOptions);
            }
        };
        this.sendVoice = function (text) {
            var self = _this;
            if (self.res) {
                self.res.json({
                    message: text
                });
                metrics.increment("events.messages.count", {
                    "user": self.bot,
                    "source": "voice",
                    "type": "sent",
                    "uid": self.sender,
                    "message": self.data.message || ""
                });
                vault.createMessage({
                    from: self.bot,
                    to: self.sender,
                    reqPayload: text,
                    bot: 'voice'
                });
            }
        };
        this.sendCard = function (card, options) {
            var self = _this;
            return new Promise(function (resolve) {
                card.conversationId = self.googleConversationId;
                if (!options) {
                    options = {};
                }
                if (options.shouldEndSession) {
                    card.shouldEndSession = options.shouldEndSession;
                }
                if (self.source === 'googleAssistant') {
                    self.messageArray.push(card);
                    return resolve();
                }
                else {
                    resolve();
                }
            });
        };
        this.sendCards = function (cards, hideInput, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var obj = { cards: cards };
                if (!self.runDefaultFunction) {
                    vault.createMessage(self.sender, self.source, self.bot, self.sessionId, JSON.stringify(obj), self.sessionObject, self.receivedMessageTime, self.messageId, self.orchestratorBotId);
                }
                if (self.source === "yellowmessenger") {
                    obj['hideInput'] = hideInput;
                }
                if (self.source === "alexa") {
                    if (options && options.shouldEndSession) {
                        obj['shouldEndSession'] = options.shouldEndSession;
                    }
                    return self.sendMessage(obj, self.res, self.bot, self.sender, function () {
                        resolve();
                    });
                }
                if (self.source === "googleAssistant") {
                    obj['conversationId'] = self.googleConversationId;
                    if (options && options.shouldEndSession) {
                        obj['shouldEndSession'] = options.shouldEndSession;
                    }
                    if (options && options.suggestions) {
                        obj['suggestions'] = options.suggestions;
                    }
                }
                if (self.source === "kookoo") {
                    return self.sendMessage(obj, self.res, self.bot, self.sender, self.sid, function () {
                        resolve();
                    });
                }
                if (((options && options.target_language) || (self.options && self.options.targetLanguage && self.options.targetLanguage !== 'en')) && !self.options.i18n) {
                    var language = options && options.target_language ? options.target_language : self.options.targetLanguage;
                    var messages = [];
                    messages = messages.concat(_.map(cards, function (option) {
                        return option.title;
                    }));
                    translateClient.translate(messages, language, function (err, translation) {
                        if (cards.length === 1) {
                            cards[0].title = translation;
                        }
                        else {
                            cards = _.map(cards, function (option, i) {
                                option.title = translation[i];
                                return option;
                            });
                        }
                        obj['cards'] = cards;
                        if (self.source === 'yellowmessenger') {
                            obj = _.assign(obj, self.xmppObj);
                            if (self.runDefaultFunction) {
                                self.messageArray.push(obj);
                                return resolve();
                            }
                            else {
                                return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                                    return resolve();
                                });
                            }
                        }
                        else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                            return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                        else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                            self.messageArray.push(obj);
                            return resolve();
                        }
                    });
                }
                else {
                    if (self.source === 'yellowmessenger') {
                        obj = _.assign(obj, self.xmppObj);
                        if (self.runDefaultFunction) {
                            self.messageArray.push(obj);
                            return resolve();
                        }
                        else {
                            return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                                return resolve();
                            });
                        }
                    }
                    else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                        return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                            return resolve();
                        });
                    }
                    else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                }
            });
        };
        // TODO Send multiple messages
        this.sendMessagesFromArr = function (arr, callback) {
            var self = _this;
            if (arr.length > 0) {
                var message = arr.shift();
                if (arr.length > 0) {
                    self.sendMessage(self.sender, { message: message }, self.bot, function () {
                        self.sendMessagesFromArr(arr, callback);
                    });
                }
                else {
                    self.sendMessage(self.sender, { message: message }, self.bot, function () {
                        if (callback)
                            callback();
                    });
                }
            }
        };
        this.sendResponseToUser = function (sender, obj, extraParams) {
            // return getContextOfOtherUser(bot,sender).then(context => {
            //     // if(context.complete || context.complete === undefined) {
            //     //     return sendResponse(bot, sender, source, {quickReplies: obj}, mapping);
            //     // }
            //     // return Promise.resolve();
            //     return sendResponse(bot, sender, source, {quickReplies: obj}, mapping);
            // }).then(() => {
            //     return Promise.resolve();
            // });
            var self = _this;
            if (self.source === 'botframework') {
                var userMapping = _.cloneDeep(self.mapping);
                userMapping.serviceUrl = extraParams.serviceUrl;
                var messageType = extraParams.messageType || 'message';
                var data = {};
                data[messageType] = obj;
                return sendResponse(self.bot, sender, self.source, data, userMapping);
            }
            else {
                var messageType = extraParams.messageType || 'message';
                var data = {};
                data[messageType] = obj;
                return sendResponse(self.bot, sender, self.source, data);
            }
        };
        this.sendAdaptiveCard = function (adaptiveCard) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'botframework') {
                    if (typeof adaptiveCard !== 'object') {
                        return reject("Adaptive Card has to be an Object");
                    }
                    var obj = {
                        adaptiveCard: adaptiveCard
                    };
                    return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                        return resolve();
                    });
                }
                else {
                    return reject("Not Supported");
                }
            });
        };
        this.sendFlightDetails = function (data, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'yellowmessenger') {
                    var obj = { flightDetails: data };
                    obj = _.assign(obj, self.xmppObj);
                    if (self.runDefaultFunction) {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                    else {
                        return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                            return resolve();
                        });
                    }
                }
            });
        };
        this.sendBoardingPasses = function (data, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'yellowmessenger') {
                    var obj = { boardingPasses: data };
                    obj = _.assign(obj, self.xmppObj);
                    if (self.runDefaultFunction) {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                    else {
                        return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                            return resolve();
                        });
                    }
                }
            });
        };
        this.sendWebViews = function (data, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'yellowmessenger') {
                    var obj = { webViews: data };
                    obj = _.assign(obj, self.xmppObj);
                    if (self.runDefaultFunction) {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                    else {
                        return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                            return resolve();
                        });
                    }
                }
            });
        };
        this.sendTextMessage = function (message, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (!message) {
                    message = "Empty message";
                }
                var messages = message.split("::");
                message = messages[Math.floor(Math.random() * 1000 % messages.length)];
                var obj = { message: message };
                if (!self.runDefaultFunction) {
                    vault.createMessage(self.sender, self.source, self.bot, self.sessionId, JSON.stringify(obj), self.sessionObject, self.receivedMessageTime, self.messageId, self.orchestratorBotId);
                }
                if (self.source === "yellowmessenger") {
                    if (!options) {
                        options = {};
                    }
                    obj.hideInput = options.hideInput;
                    obj.keyboardType = options.keyboardType;
                    obj.update = options.update;
                }
                if (self.source === "twilio") {
                    if (!options) {
                        options = {};
                    }
                    if (options.saveMessage) {
                        self.memory.set("saveMessage", message);
                        resolve();
                    }
                    else {
                        twilio.sendMessage(obj, self.res, self.bot, self.sender, function () {
                            resolve();
                        });
                    }
                    return;
                }
                if (self.source === "alexa") {
                    if (!options) {
                        options = {};
                    }
                    if (options.shouldEndSession) {
                        obj.shouldEndSession = options.shouldEndSession;
                    }
                    if (options.audio) {
                        obj.audio = options.audio;
                    }
                    if (options.card) {
                        obj.alexaCard = options.card;
                    }
                    if (options.saveMessage) {
                        self.memory.set("saveMessage", message);
                        resolve();
                    }
                    else {
                        self.sendMessage(obj, self.res, self.bot, self.sender, function () {
                            resolve();
                        });
                    }
                    return;
                }
                if (self.source === "slack") {
                    obj.channel = self.slackChannel;
                    obj.token = self.slackToken;
                    // axiosInstance.post('/slack/send', {
                    //     data: {
                    //         message: obj,
                    //         options: options,
                    //         bot: bot,
                    //         sender: sender
                    //     }
                    // }).then(function (response) {
                    //     return resolve();
                    // })
                    //     .catch(function (error) {
                    //         return reject();
                    //     });
                }
                if (self.source === "kookoo") {
                    return self.sendMessage(obj, self.res, self.bot, self.sender, self.sid, function () {
                        resolve();
                    });
                }
                if (self.source === "googleAssistant") {
                    if (!options) {
                        options = {};
                    }
                    obj.conversationId = self.googleConversationId;
                    if (options.shouldEndSession) {
                        obj.shouldEndSession = options.shouldEndSession;
                    }
                    if (options.requestLocation) {
                        obj.requestLocation = options.requestLocation;
                    }
                    obj.optContext = "";
                    if (options.optContext) {
                        obj.optContext = options.optContext;
                    }
                    if (options.audio) {
                        obj.audio = options.audio;
                    }
                    if (options.speechMessage) {
                        obj.speechMessage = options.speechMessage;
                    }
                    if (options.auth) {
                        obj.auth = options.auth;
                    }
                }
                if (((options && options.target_language) || (self.options && self.options.targetLanguage && self.options.targetLanguage !== 'en')) && !self.options.i18n) {
                    var language_1 = options && options.target_language ? options.target_language : self.options.targetLanguage;
                    translateClient.translate(message, language_1, function (err, translation) {
                        obj.message = translation;
                        if (self.source === 'yellowmessenger') {
                            obj = _.assign(obj, self.xmppObj);
                            if (self.runDefaultFunction) {
                                self.messageArray.push(obj);
                                return resolve();
                            }
                            else {
                                return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                                    return resolve();
                                });
                            }
                        }
                        else if (self.source === 'sms') {
                            return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                        else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                            return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                        else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                            self.messageArray.push(obj);
                            return resolve();
                        }
                        else if (self.source === "voice") {
                            obj.lang = language_1;
                            self.messageArray.push(obj);
                            return resolve();
                        }
                    });
                }
                else {
                    if (self.source === 'yellowmessenger') {
                        obj = _.assign(obj, self.xmppObj);
                        if (self.runDefaultFunction) {
                            self.messageArray.push(obj);
                            return resolve();
                        }
                        else {
                            return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                                return resolve();
                            });
                        }
                    }
                    if (self.source === 'sms') {
                        return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                            return resolve();
                        });
                    }
                    else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                        if (options && options.uid) {
                            return sendResponse(self.bot, options.uid, self.source, obj, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                        else {
                            return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                    }
                    else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                    else if (self.source === "voice") {
                        obj.lang = self.options.targetLanguage;
                        self.messageArray.push(obj);
                        return resolve();
                    }
                }
            });
        };
        this.sendTyping = function () {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'yellowmessenger') {
                    sendTyping(self.bot, self.sender).then(function (res) {
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            });
        };
        this.sendWebView = function (title, url, height, options) {
            var self = _this;
            return new Promise(function (resolve) {
                var obj = {
                    webView: {
                        title: title,
                        url: url,
                        height: height || 250
                    }
                };
                if (options && options.hideInput) {
                    obj.hideInput = true;
                }
                if (self.source === 'yellowmessenger') {
                    if (self.runDefaultFunction) {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                    else {
                        return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                            return resolve();
                        });
                    }
                }
                else {
                    return resolve();
                }
            });
        };
        this.sendQuickReplies = function (quickReplies, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (!quickReplies) {
                    return reject();
                }
                var messages = quickReplies.title.split("::");
                quickReplies.title = messages[Math.floor(Math.random() * 1000 % messages.length)];
                var obj = { quickReplies: quickReplies };
                if (!self.runDefaultFunction) {
                    vault.createMessage(self.sender, self.source, self.bot, self.sessionId, JSON.stringify(obj), self.sessionObject, self.receivedMessageTime, self.messageId, self.orchestratorBotId);
                }
                if (self.source === "yellowmessenger") {
                    if (!options) {
                        options = {};
                    }
                    obj.hideInput = options.hideInput;
                    obj.keyboardType = options.keyboardType;
                    obj.update = options.update;
                }
                if (self.source.toLowerCase() === 'facebook') {
                    quickReplies.options = _.map(quickReplies.options, function (option) {
                        if (option.facebookTitle && option.facebookTitle.length > 0) {
                            option.title = option.facebookTitle;
                        }
                        return option;
                    });
                }
                if (self.source === "alexa") {
                    if (options && options.shouldEndSession) {
                        obj.shouldEndSession = options.shouldEndSession;
                    }
                    return self.sendMessage(obj, self.res, self.bot, self.sender, function () {
                        resolve();
                    });
                }
                if (self.source === "slack") {
                    obj.channel = self.slackChannel;
                    obj.token = self.slackToken;
                }
                if (self.source === "googleAssistant") {
                    if (!options) {
                        options = {};
                    }
                    obj.conversationId = self.googleConversationId;
                    if (options.shouldEndSession) {
                        obj.shouldEndSession = options.shouldEndSession;
                    }
                    if (options.speechMessage) {
                        obj.speechMessage = options.speechMessage;
                    }
                    if (options.requestLocation) {
                        obj.requestLocation = options.requestLocation;
                    }
                    obj.conversationId = self.googleConversationId;
                }
                if (self.source === "kookoo") {
                    return self.sendMessage(obj, self.res, self.bot, self.sender, self.sid, function () {
                        resolve();
                    });
                }
                if (((options && options.target_language) || (self.options && self.options.targetLanguage && self.options.targetLanguage !== 'en')) && !self.options.i18n) {
                    var language = options && options.target_language ? options.target_language : self.options.targetLanguage;
                    var messages_1 = [];
                    messages_1.push(quickReplies.title);
                    quickReplies.options.forEach(function (option) {
                        messages_1.push(option.title);
                    });
                    translateClient.translate(messages_1, language, function (err, translation) {
                        quickReplies.title = translation[0];
                        quickReplies.options = _.map(quickReplies.options, function (option, i) {
                            if (translation[i + 1] && translation[i + 1].length > 0) {
                                option.title = translation[i + 1];
                            }
                            return option;
                        });
                        if (self.source === 'kookoo') {
                            return self.sendMessage({ quick_replies: quickReplies }, self.res, self.bot, self.sender, self.sid, self.options.kookoo_language, function () {
                                resolve();
                            });
                        }
                        if (self.source === 'voice') {
                            obj.message = translation;
                            return self.sendMessage(obj, self.res, self.bot, self.sender, function () {
                                resolve();
                            });
                        }
                        if (self.source === 'yellowmessenger') {
                            obj = _.assign(obj, self.xmppObj);
                            if (self.runDefaultFunction) {
                                self.messageArray.push(__assign({ quickReplies: quickReplies }, obj));
                                return resolve();
                            }
                            else {
                                return sendResponse(self.bot, self.sender, 'yellowmessenger', __assign({ quickReplies: quickReplies }, obj)).then(function () {
                                    return resolve();
                                });
                            }
                        }
                        else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                            return sendResponse(self.bot, self.sender, self.source, { quickReplies: quickReplies }, self.mapping).then(function () {
                                return resolve();
                            });
                        }
                        else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                            self.messageArray.push({ quickReplies: quickReplies });
                            return resolve();
                        }
                    });
                }
                else {
                    if (self.source === 'yellowmessenger') {
                        obj = _.assign(obj, self.xmppObj);
                        if (self.runDefaultFunction) {
                            self.messageArray.push(obj);
                            return resolve();
                        }
                        else {
                            return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                                return resolve();
                            });
                        }
                    }
                    else if (self.source === 'facebook' || self.source === 'botframework' || self.source === 'skype') {
                        return sendResponse(self.bot, self.sender, self.source, obj, self.mapping).then(function () {
                            return resolve();
                        });
                    }
                    else if (self.source === 'alexa' || self.source === 'googleAssistant') {
                        self.messageArray.push(obj);
                        return resolve();
                    }
                }
            });
        };
        this.sendEvent = function (event, options) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'yellowmessenger') {
                    return sendResponse(self.bot, self.sender, 'yellowmessenger', { event: event }).then(function () {
                        return resolve();
                    });
                }
            });
        };
        this.sendImagesInternal = function (imagesArr, n) {
            var self = _this;
            if (n < imagesArr.length) {
                return self.sendImage(imagesArr[n])
                    .then(function () {
                    return self.sendImagesInternal(imagesArr, n + 1);
                });
            }
            else {
                return Promise.resolve();
            }
        };
        this.sendMessagesInternal = function (messageArr, n) {
            var self = _this;
            if (n < messageArr.length) {
                return self.sendTextMessage(messageArr[n], {})
                    .then(function () {
                    return self.sendMessagesInternal(messageArr, n + 1);
                });
            }
            else {
                return Promise.resolve();
            }
        };
        // Send Multiple Images at once to the user with order being maintained
        this.sendMultipleImages = function (imageArr) {
            var self = _this;
            return new Promise(function (resolve) {
                self.sendImagesInternal(imageArr, 0).then(function () {
                    return resolve();
                });
            });
        };
        //Uploading a file to the blob and getting the signed URL
        this.uploadFile = function (buffer, fileName, expiryTime) {
            return new Promise(function (resolve) {
                createSasUrl(buffer, fileName, expiryTime).then(function (url) {
                    return resolve(url);
                })["catch"](function (err) {
                    return resolve(err);
                });
            });
        };
        this.sendMultipleTextMessages = function (messageArr, options) {
            var self = _this;
            return new Promise(function (resolve) {
                if (options && options.random) {
                    var messageIndex = 0;
                    if (messageArr && messageArr.length > 0) {
                        messageIndex = Math.floor(Math.random() * Math.floor(messageArr.length));
                    }
                    self.sendMessagesInternal(messageArr, 0).then(function () {
                        return resolve();
                    });
                }
                else {
                    self.sendMessagesInternal(messageArr, 0).then(function () {
                        return resolve();
                    });
                }
            });
        };
        this.sendImage = function (image) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                var obj = {
                    image: image
                };
                if (self.runDefaultFunction) {
                    self.messageArray.push(obj);
                    return resolve();
                }
                else {
                    return sendResponse(self.bot, self.sender, 'yellowmessenger', obj).then(function () {
                        return resolve();
                    });
                }
            });
        };
        this.sendAirlineItinerary = function (airlineIter) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (self.source === 'facebook') {
                    return sendResponse(self.bot, self.sender, 'facebook', { airline_itinerary: airlineIter }).then(function () {
                        return resolve();
                    });
                }
                else {
                    return reject();
                }
            });
        };
        this.sendGoogleImageTracker = function (imageUrl) {
            var self = _this;
            return new Promise(function (resolve) {
                if (self.source === 'yellowmessenger') {
                    return sendResponse(self.bot, self.sender, 'yellowmessenger', { googleTracker: { img: imageUrl } }).then(function () {
                        return resolve();
                    });
                }
            });
        };
        /*
         Parameter - {url : 'URL_TO_THE_VIDEO'} or {attachment_id: 'Attachment ID'}
         Attachment ID paramter only works for Facebook Messenger and will be discarded
         for all other platforms.
         */
        this.sendVideo = function (video) {
            var self = _this;
            return new Promise(function (resolve, reject) {
                if (video.url) {
                    if (self.source === 'yellowmessenger') {
                        return sendResponse(self.bot, self.sender, 'yellowmessenger', { video: video }).then(function () {
                            return resolve();
                        });
                    }
                }
                else if (video.attachment_id && self.source === 'facebook') {
                    if (self.source === 'facebook') {
                        return sendResponse(self.bot, self.sender, 'facebook', { video: video }).then(function () {
                            return resolve();
                        });
                    }
                }
                else {
                    reject({ message: 'Invalid Attachment. Message not sent.' });
                }
            });
        };
        // Feedback Related
        this.feedbackEvent = {
            feedbackProvided: function () {
                var self = _this;
                if (self.data.event && self.data.event === 'feedback-event') {
                    return {
                        event: self.data.event,
                        data: self.data.data
                    };
                }
                else {
                    return false;
                }
            }
        };
        this.successFactors = {
            getUser: function (userId) {
                var self = _this;
                return new Promise(function (resolve, reject) {
                    if (self.mapping && self.mapping.auth && self.mapping.auth.successFactors && self.mapping.auth.successFactors.username) {
                        var url = "https://api8.successfactors.com/odata/v2/User('" + userId + "')?$select=payGrade,userId,division,location,firstName,lastName,email,username,addressLine1,department,custom07,division,location,gender,status,city,state,zipCode,custom01,jobCode,manager/userId,manager/username,incumbentOfPositionNav/payGradeNav/name&$expand=manager,empInfo/jobInfoNav,empInfo,incumbentOfPositionNav/payGradeNav&$format=json";
                        var options = {
                            method: 'GET',
                            url: url,
                            headers: {
                                'cache-control': 'no-cache',
                                'content-type': 'application/json',
                                authorization: "Basic " + (new Buffer(self.mapping.auth.successFactors.username + ":" + self.mapping.auth.successFactors.password).toString('base64'))
                            },
                            json: true
                        };
                        request(options, function (error, response, dataBody) {
                            if (error || dataBody.error || !dataBody.d) {
                                reject(dataBody && dataBody.error ? dataBody.error.message : "error");
                            }
                            else {
                                resolve(dataBody.d);
                            }
                        });
                    }
                    else {
                        reject("authorization token unavailable");
                    }
                });
            }
        };
        this.geoCode = geoUtil.geoCode;
        this.reverseGeoCode = geoUtil.reverseGeoCode;
        this.azure = {
            auth: function () {
                var self = _this;
                var stateParams = encodeURIComponent(new Buffer(JSON.stringify({
                    bot: self.bot,
                    source: self.source,
                    sender: self.sender
                })).toString('base64'));
                return "https://login.microsoftonline.com/" + self.mapping.auth.azure.tenant_id + "/oauth2/" + (self.mapping.auth.azure.version
                    ? self.mapping.auth.azure.version + '/' : '') + "authorize?client_id=" + self.mapping.auth.azure.client_id + "&response_type=code&redirect_uri=" + bpConfig.urls.AZURE_URL_REDIRECT + "\n            &response_mode=query&state=" + stateParams + (self.mapping.auth.azure.domain_hint ? '&domain_hint=' + self.mapping.auth.azure.domain_hint : '') + (self.mapping.auth.azure.scope ? '&scope=' + self.mapping.auth.azure.scope : '');
            },
            authReceived: function () {
                var self = _this;
                return self.data.event && self.data.event === 'azure-auth-success';
            },
            user: function (accessToken) {
                return new Promise(function (resolve, reject) {
                    var options = {
                        method: 'GET',
                        url: 'https://graph.windows.net/me',
                        qs: { 'api-version': '1.6' },
                        headers: {
                            'cache-control': 'no-cache',
                            'content-type': 'application/json',
                            authorization: 'Bearer ' + accessToken
                        },
                        json: true
                    };
                    request(options, function (error, response, dataBody) {
                        if (error || dataBody['odata.error']) {
                            reject('error');
                        }
                        else {
                            resolve(dataBody);
                        }
                    });
                });
            }
        };
        this.sender = options["sender"];
        this.bot = options["bot"];
        this.privateBot = options["bot"];
        this.mapping = options["mapping"];
        this.source = options["source"];
        this.profile = options["profile"];
        // this.profileOriginal = _.clone(this.profile, true);
        this.botIdentifier = options["botIdentifier"];
        this.maximumAssignedCount = this.mapping && this.mapping.maximumAssignedCount || undefined;
        //for Google assistant
        this.googleConversationId = options["data"] && options["data"]["conversationId"] ? options["data"]["conversationId"] : '';
        this.googleSurfaceCapabilities = options["data"] && options["data"]["capabilities"] ? options["data"]["capabilities"] : [];
        //for slack
        this.slackChannel = options["data"] && options["data"]["slackChannel"] ? options.data.slackChannel : '';
        this.slackToken = options.data && options.data.slackToken ? options.data.slackToken : '';
        //an array where bot responses are saved before pushing to vault
        this.messageArray = [];
        //for facebook
        this.signature = '6cab9a2aada111452fa2db8ba663fb6e29208d76e6b27b8ec75e97482bf70d2f';
        this.publishInternal = options.publish;
        var self = this;
        //saving the messageId and sessionId
        this.messageId = options.messageId;
        this.runDefaultFunction = options.runDefaultFunction;
        this.sessionObject = options.sessionObject;
        this.sessionId = this.sessionObject && this.sessionObject.sessionId ? this.sessionObject.sessionId : undefined;
        this.receivedMessageTime = options.receivedMessageTime;
        this.bot = options.bot;
        this.botIdentifier = options.botIdentifier;
        //an object is made for passing  journey and step info to xmpp
        this.xmppObj = {};
        this.referrer = options.referrer;
        // triggerJourney is assigned for defaultFunction to handle journey in the bot
        this.triggerJourney = options.triggerJourney;
        this.orchestratorBotId = options.orchestratorBotId;
        this.allFunctions = functions;
        this.term = options.term;
        // Non private
        this.source = options.source;
        this.sender = options.sender;
        this.data = options.data;
        this.profile = options.profile;
        // External Libraries
        this.imageRequest = imageRequest;
        this.fileRequest = self.imageRequest;
        this.q = Q;
        this.xmlToJSON = xml2json;
        this.numeral = numeral;
        this.axios = axios;
        this.geolib = geolib;
        this.time = time;
        this._ = _;
        this.crypto = crypto;
        this.cheerio = cheerio;
        this.sanitizeHTML = sanitizeHtml;
        this.mustache = mustache;
        this.translate = translateClient;
        this.phoneParse = phoneParse;
        this.phonetics = phonetics;
        this.soap = soap;
        this.insecureAgent = new https.Agent({
            rejectUnauthorized: false
        });
        //Utilities
        this.random = Math.random;
        this.floor = Math.floor;
        this.ceil = Math.ceil;
        // Yellow Messenger Libraries
        this.dataStore = new DataStore(this.privateBot);
        this.datastore = this.dataStore;
        this.ai = new AI(this.privateBot);
        this.res = options.res;
        this.sid = options.sid;
        this.execStartTime = options.execStartTime;
        this.memory = new Memory(this.bot, this.sender);
        this.analytics = new Analytics(this.sender, this.bot, this.source, this.profile, this.data);
        this.logger = new Logger(this.bot, this.sender, this.source);
        this.log = this.logger.log;
        this.contextProcessor = new ContextProcessor(this, this.mapping);
        this.getContext = this.contextProcessor.getContext;
        this.setContextParam = this.contextProcessor.setContextParam;
        this.setContextMultiple = this.contextProcessor.setContextMultiple;
        this.resetContext = this.contextProcessor.resetContext;
        this.deleteContextParam = this.contextProcessor.deleteContextParam;
        this.setStep = this.contextProcessor.setContextParam;
        this.setMultipleSteps = this.contextProcessor.setContextMultiple;
        this.setSteps = this.contextProcessor.setContextMultiple;
        this.deleteStep = this.contextProcessor.deleteContextParam;
        this.orchestrator = new Orchestrator(this, this.mapping);
        switch (this.source) {
            case 'alexa':
                this.sendMessage = alexa.sendMessage;
                break;
            case 'kookoo':
                this.sendMessage = kookoo.sendMessage;
                break;
            case 'facebook':
                this.sendMessage = facebook.sendMessageBeta;
                break;
            case 'googleAssistant':
                this.sendMessage = googleAssistant.sendMessage;
                break;
            case 'yellowmessenger':
                this.sendMessage = ym.sendMessage;
                break;
            case 'telegram':
            case 'msteams':
            case 'botframework':
            case 'skype':
            case 'slack':
            case 'webchat':
                this.sendMessage = botframework.sendMessage;
                break;
            case 'email':
                this.sendMessage = self.sendEmailMessage;
                break;
            case 'sms':
                this.sendMessage = sms.sendMessage;
                break;
            case 'line':
                this.sendMessage = line.sendMessage;
                break;
        }
    }
    return App;
}());
exports.App = App;
var clearContextWithOrchestrator = function (bot, uid, triggerBot) {
    return new Promise(function (resolve) {
        var app = new App({
            sender: uid,
            bot: bot,
            botIdentifier: bot,
            profile: {},
            source: 'yellowmessenger',
            data: {
                message: ''
            }
        });
        var clearContext = function () {
            app.getContext().then(function () {
                app.clearContext();
            });
        };
        app.orchestrator.getContext().then(function () {
            // clearing the childbots context
            if (app.orchestrator.context && app.orchestrator.context.current) {
                app.orchestrator.clearChildBotsContext(app.orchestrator.context.current).then(function () {
                    if (triggerBot) {
                        app.orchestrator.clearChildBotsContext(triggerBot).then(function () {
                            app.orchestrator.setBot(triggerBot);
                            clearContext();
                            resolve();
                        });
                    }
                    else {
                        clearContext();
                        resolve();
                    }
                });
            }
            else {
                clearContext();
                resolve();
            }
        });
    });
};
exports.clearContextWithOrchestrator = clearContextWithOrchestrator;
function updateFunctions(funcs) {
    _.merge(functions, funcs);
}
exports.updateFunctions = updateFunctions;
