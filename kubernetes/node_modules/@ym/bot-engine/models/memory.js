'use strict';

const axios = require('axios');
const config = require('../config');
const baseURL = config.urls.DATA_SERVICE;
let Redis = require('ioredis');
const localCache = require('./localCache');
const axiosInstance = axios.create({
    baseURL,
    headers: {"x-auth-token": process.env['apiKey']}
});
const NODE_ENVIRONMENT = process.env['NODE_ENV'];
let redisClient;
if (NODE_ENVIRONMENT === 'docker') {
    if (config.redis.cluster && config.redis.cluster.options) {
        redisClient = new Redis.Cluster(config.redis.cluster.nodes, config.redis.cluster.options);
    } else {
        redisClient = config.redis.cluster ? new Redis.Cluster(config.redis.cluster.nodes) : new Redis(config.redis.port, config.redis.host);
    }
}


const hdel = (key, dataKey) => {
    get(key).then(function (data) {
        let dataObj = JSON.parse(data);
        delete dataObj[dataKey];
        redisClient.set(key, JSON.stringify(dataObj));
    });
};
const axiosDataWrapper = (data, serviceName) => {
    return axiosInstance({
        method: 'post',
        url: `/internal/redis/${serviceName}`,
        data
    }).then((response) => {
        response = response.data;
        if (response.success) {
            return response.data;
        } else {
            return Promise.reject(new Error(response.data));
        }
    });
};

const refreshContext = (botId, sender) => {
    let prefix = 'vstore_' + botId + '_' + sender + '_' + 'context';
    let context = localCache.get(prefix);
    context = JSON.parse(context);
    if (context) {
        if (!context.history) {
            context.history = [];
        }

        if (context.intent) {
            if (context.steps || !context.entities) {
                context.history.push({
                    intent: context.intent,
                    complete: context.complete,
                    steps: _.cloneDeep(context.steps)
                });
            } else {
                context.history.push({
                    intent: context.intent,
                    complete: context.complete,
                    steps: _.cloneDeep(context.entities)
                });
            }
            // Store only last 10 intents in the memory
            context.history = context.history.splice(-1 * 5);
        }

        // Store the previous entities as well
        delete context.paramExpected;
        delete context.question;
        delete context.options;
        delete context.steps;
        delete context.complete;
        delete context.invalidCount;
        delete context.intent;
        delete context.journeyName;
        delete context.stepId;
        delete context.entities;
        localCache.put(prefix, typeof context === 'object' ? JSON.stringify(context) : context, 172800);
    }
    return Promise.resolve();

};

// Temporary storage
let Memory = function (bot, sender) {
    let prefix = "vstore_" + bot + "_" + sender + "_";
    let self = this;

    this.set = function (key, data, expiry) {
        key = prefix + key;
        if (NODE_ENVIRONMENT === 'docker') {
            redisClient.set(key, typeof data === 'object' ? JSON.stringify(data) : data);
            if (expiry) {
                redisClient.expire(key, expiry);
            } else {
                redisClient.expire(key, 172800);
            }
            return Promise.resolve();
        } else {
            localCache.put(key, typeof data === 'object' ? JSON.stringify(data) : data, expiry || 172800);
            return Promise.resolve();
        }
    };

    this.delete = function (key) {
        key = prefix + key;
        if (NODE_ENVIRONMENT === 'docker') {
            redisClient.del(key);
        } else {
            localCache.del(key);
        }
    };

    this.del = this.delete;

    this.get = function (key) {
        return new Promise((resolve, reject) => {
            key = prefix + key;
            if (NODE_ENVIRONMENT === 'docker') {
                redisClient.get(key, function (err, data) {
                    if (err) {
                        reject(err);
                    } else if (!data) {
                        reject(new Error('no data'));
                    } else {
                        resolve(data);
                    }
                });
            } else {
                let value = localCache.get(key);
                if (value) {
                    resolve(value);
                } else {
                    reject("key doesnt exist");
                }
            }
        });
    };


    this.hmset = (key, dataKey, dataValue) => {
        self.get(key).then((data) => {
            let dataObj = JSON.parse(data);
            dataObj[dataKey] = dataValue;
            self.set(key, JSON.stringify(dataObj));
        }, function () {
            self.set(key, JSON.stringify({
                dataKey: dataValue
            }));
        });
    };

    this.hdel = function (key, dataKey) {
        return self.get(key).then(function (data) {
            let dataObj = JSON.parse(data);
            delete dataObj[dataKey];
            return self.set(key, JSON.stringify(dataObj));
        });
    };

    this.getMultiple = function (keys) {
        return new Promise(function (resolve) {
            let arrFunc = _.map(keys, function (key) {
                return self.get(key);
            });

            Q.allSettled(arrFunc).then(function (results) {
                resolve(_.mapValues(_.keyBy(_.map(results, function (result, index) {
                    return {
                        key: keys[index],
                        value: result.state === "fulfilled" ? result.value : undefined
                    }
                }), 'key'), 'value'));
            });
        });
    };

};

//to access other context
function getContextOfOtherUser(bot, sender) {

    let prefix = "vstore_" + bot + "_" + sender + "_";
    let key = 'context';
    let data = {key: prefix + key};
    return axiosDataWrapper(data, 'get').then(function (contextString) {
        contextString = JSON.parse(contextString);
        resolve(contextString);
    }, function () {
        resolve({});
    });
}

module.exports = {
    Memory,
    getContextOfOtherUser,
    refreshContext,
    set: function (key, data, expiry) {
        if (NODE_ENVIRONMENT === 'docker') {
            redisClient.set(key, typeof data === 'object' ? JSON.stringify(data) : data);
            if (expiry) {
                redisClient.expire(key, expiry);
            } else {
                redisClient.expire(key, 172800);
            }
            return Promise.resolve();
        } else {
            localCache.put(key, typeof data === 'object' ? JSON.stringify(data) : data, expiry || 172800);
            return Promise.resolve();
        }
    },
    get: function (key) {
        return new Promise((resolve, reject) => {
            if (NODE_ENVIRONMENT === 'docker') {
                redisClient.get(key, function (err, data) {
                    if (err) {
                        reject(err);
                    } else if (!data) {
                        reject(new Error('no data'));
                    } else {
                        resolve(data);
                    }
                });
            } else {
                let value = localCache.get(key);
                if (value) {
                    resolve(value);
                } else {
                    reject("key doesnt exist");
                }
            }
        });
    },
    del: function (key) {
        if (NODE_ENVIRONMENT === 'docker') {
            redisClient.del(key);
        } else {
            localCache.del(key);
        }
    }
};

