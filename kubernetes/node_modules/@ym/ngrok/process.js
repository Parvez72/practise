const { spawn } = require("child_process");
const platform = require("os").platform();

const defaultDir = __dirname + "/bin";
const bin = "./ngrok" + (platform === "win32" ? ".exe" : "");
const ready = /Serving web interface on (\d+\.\d+\.\d+\.\d+:\d+)/;
const inUse = /address already in use/;
const jsonPayloadRegex = /Read message .*\n/;

let processPromise, activeProcess;

/*
	ngrok process runs internal ngrok api
	and should be spawned only ONCE 
	(respawn allowed if it fails or .kill method called)
*/

async function getProcess(opts) {
  if (processPromise) return processPromise;
  try {
    processPromise = startProcess(opts);
    return await processPromise;
  } catch (ex) {
    processPromise = null;
    throw ex;
  }
}

async function startProcess(opts) {
  let dir = defaultDir;
  const start = ["-log=stdout"];
  start.push("-config=" + __dirname + "/ngrok.yml");
  if (opts.subdomain) {
    start.push("-subdomain=" + opts.subdomain);
  }
  if (opts.port) {
    start.push(opts.port);
  }
  if (opts.binPath) dir = opts.binPath(dir);

  const ngrok = spawn(bin, start, { cwd: dir });
  let lastMessage = "";

  let resolve, reject;
  const apiUrl = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });

  ngrok.stdout.on("data", data => {
    const msg = data.toString();
    lastMessage = msg;
    const addr = msg.match(ready);
    let jsonPayload;
    if (msg.match(jsonPayloadRegex)) {
      const matchedString = msg.match(jsonPayloadRegex);
      jsonPayload = JSON.parse(matchedString[0].replace("Read message ", ""));

      if (jsonPayload.Payload.Error) {
        return reject(new Error(jsonPayload.Payload.Error));
      } else if (
        !jsonPayload.Payload.Error &&
        jsonPayload.Type === "NewTunnel" &&
        jsonPayload.Payload.Protocol === "https"
      ) {
        return resolve(jsonPayload.Payload.Url);
      }
    }
  });

  ngrok.stderr.on("data", data => {
    const msg = data.toString().substring(0, 10000);
    reject(new Error(msg));
  });

  ngrok.on("exit", (code, signal) => {
    processPromise = null;
    activeProcess = null;
    if (code !== 0) {
      reject(new Error(lastMessage));
    }
  });

  process.on("exit", async () => await killProcess());

  try {
    const url = await apiUrl;
    activeProcess = ngrok;
    return url;
  } catch (ex) {
    ngrok.kill();
    throw ex;
  } finally {
    ngrok.stdout.removeAllListeners("data");
    ngrok.stderr.removeAllListeners("data");
  }
}

function killProcess() {
  if (!activeProcess) return;
  return new Promise(resolve => {
    activeProcess.on("exit", () => resolve());
    activeProcess.kill();
  });
}

module.exports = {
  getProcess,
  killProcess
};
