#!/usr/bin/env node
const chalk = require("chalk");
const figlet = require("figlet");
const clog = console.log;
const _ = require("lodash");
const commandLineArgs = require("command-line-args");
const ngrok = require("@ym/ngrok");
const open = require('open');
const CURRENT_PATH = process.cwd();
const path = require('path');
const {spawn} = require('child_process');

const {
    ymrcDoesExist,
    getConfig,
    writeConfig,
    updateConfig,
    botDirExists
} = require("./fileUtils");
const {getBotMappings, gitInit} = require("./botMapping");

const {
    askAPIKey,
    askBot,
    initiateRepo,
    commitAndPush,
    deployToYm,
    checkOutBranch,
    askDirectory
} = require("./helper");

const logo = "Yellow Messenger";

const run = () => {
    let mainDefinitions = [{name: "name", defaultOption: true}];
    const mainCommand = commandLineArgs(mainDefinitions, {
        stopAtFirstUnknown: true
    });
    const localConfig = getConfig();
    let mainArgv = mainCommand._unknown || [];
    switch (mainCommand.name) {
        case "init":
            clog(
                chalk.yellow(
                    figlet.textSync(logo, {
                        font: "Standard",
                        horizontalLayout: "fitted",
                        verticalLayout: "fitted"
                    })
                )
            );
            console.log("");
            console.log(chalk.red("Welcome to the 10X Enterprise"));


            askAPIKey().then(answers => {
                _.assign(localConfig, answers);
                return getBotMappings(answers.apiKey);
            }).then(data => {
                if (data.success) {
                    clog(chalk.green(data.message));
                    return Promise.resolve(data.data);
                } else {
                    clog(chalk.red(data.message));
                    return Promise.reject();
                }
            }).then(bots => {
                return askBot(bots);
            }).then(selectedBot => {
                _.assign(localConfig, selectedBot);
                return askDirectory();
            }).then((answer) => {
                _.assign(localConfig, answer);
                if (botDirExists(localConfig.directoryName)) {
                    throw Error(
                        `${localConfig.directoryName} already exists in this directory.`
                    );
                } else {
                    return gitInit(localConfig.apiKey, localConfig.botId);
                }
            }).then(userData => {
                _.assign(localConfig, userData);

            }).then(() => {
                return initiateRepo(localConfig);
            }).then(() => {
                localConfig['NODE_ENV'] = 'development';
                localConfig['urls__DATA_SERVICE'] = 'https://app.yellowmessenger.com/api/data';
                localConfig['urls__AI_BACKEND_SERVICE'] = 'https://app.yellowmessenger.com/api/ai';
                localConfig['urls__CONTROLLER_SERVICE'] = 'https://app.yellowmessenger.com/integrations';
                localConfig['urls__AGENTS_SERVICE'] = 'https://app.yellowmessenger.com/api/agents';
                localConfig['urls__ML'] = 'https://app.yellowmessenger.com/api/ml';
                return writeConfig(localConfig);
            }).then(() => {
                clog(chalk.white.bgGreen.bold(`Created ${localConfig.directoryName} directory`));
                clog(chalk.white.bgGreen.bold(`Config created at .ymrc`));
            }).catch(err => {
                console.log(err);
                clog(
                    chalk.white.bgRed.bold(err.message || "Unexpected Error Occured")
                );
            });
            break;
        case "run": {
            const runDefinitions = [
                {name: 'staging', type: Boolean}
            ];
            let argv = mainCommand._unknown;
            const runOptions = commandLineArgs(runDefinitions, {argv, stopAtFirstUnknown: true});
            let args = runOptions._unknown || [];
            if (!localConfig.uid) {
                localConfig.uid = 'local-' + new Date().getTime();
                updateConfig(localConfig);
            }
            checkOutBranch(runOptions.staging ? 'staging' : 'master').then(() => {
                return Promise.resolve();
            }).catch((error) => {
                clog(chalk.white.bgRed.bold(error));
            }).then(() => {
                const url = ngrok
                    .connect({
                        subdomain: localConfig.uid,
                        port: 8888
                    })
                    .then(url => {
                        console.log("url: ", url);
                        _.assign(process.env, localConfig);
                        const runCode = spawn('nodemon', ['--exec', '"ts-node"', './app.ts']);
                        let openChrome = false;
                        runCode.stdout.on('data', (stdoutBuffer) => {
                            console.log(stdoutBuffer.toString());
                            if (stdoutBuffer.toString().indexOf('Listening') !== -1 && !openChrome) {
                                openChrome = true;
                                open(url, {app: 'google chrome'});
                            }
                        });

                        runCode.stderr.on('data', (stderrBuffer) => {
                            console.log(stderrBuffer.toString(), "error");
                        });

                        runCode.on('close', (closeBuffer) => {
                            console.log(closeBuffer.toString(), "closed");
                        });
                    })
                    .catch(err => {
                        console.log(err);
                    });
            });
            break;
        }
        case "deploy": {

            const runDefinitions = [
                {name: 'staging', type: Boolean}
            ];
            let argv = mainCommand._unknown;
            const runOptions = commandLineArgs(runDefinitions, {argv, stopAtFirstUnknown: true});
            let args = runOptions._unknown || [];
            const branch = runOptions.staging ? 'staging' : 'master';
            if (ymrcDoesExist) {
                checkOutBranch(branch).then(() => {
                    return Promise.resolve();
                }).catch((error) => {
                    clog(chalk.white.bgRed.bold(error));
                }).then(() => {
                    commitAndPush(branch);
                    console.log("Commit & Push done");
                    localConfig.branch = branch;
                    deployToYm(localConfig)
                        .then(() => {
                            clog(chalk.white.bgGreen.bold("Successfully Deployed"));
                        }).catch(() => {
                        clog(chalk.white.bgRed.bold("Unexpected Error Occured"));

                    });
                });
            } else {
                clog(chalk.white.bgRed.bold("This is not a YM project directory"));
            }
            break;
        }
        default:
            clog(
                chalk.yellow(
                    figlet.textSync("Yellow Messenger", {
                        font: "Standard",
                        horizontalLayout: "fitted",
                        verticalLayout: "fitted"
                    })
                )
            );
            console.log("");
            console.log(chalk.red("Welcome to the 10X Enterprise"));
            clog(chalk.white.bgRed.bold("This command is not supported"));
        // code block
    }
};

run();
